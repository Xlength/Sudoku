import { writable } from 'svelte/store';
import { SUDOKU_SIZE } from '@sudoku/constants';
import { ISudokuSolver } from '../interfaces/sudoku-solver.js';
import { DefaultSudokuSolver } from '../solvers/default-sudoku-solver.js';
import { hints } from './hints';

/**
 * 用户网格管理器 - 只负责用户输入的管理
 * 
 * OOAD设计原则：
 * 1. 单一职责：只负责用户输入网格的存储和管理
 * 2. 依赖倒置：依赖ISudokuSolver接口，而非具体实现
 * 3. 依赖注入：通过构造函数注入求解器，便于测试和扩展
 */
function createUserGrid(puzzleGridStore, solver = null) {
	// 如果没有提供求解器，使用默认实现
	if (!solver) {
		solver = new DefaultSudokuSolver();
	}

	// 验证求解器接口
	if (!(solver instanceof ISudokuSolver)) {
		throw new Error('Solver must implement ISudokuSolver interface');
	}

	const userGrid = writable(Array(SUDOKU_SIZE).fill(null).map(() => Array(SUDOKU_SIZE).fill(0)));

	// 监听题目网格变化，同步到用户网格
	puzzleGridStore.subscribe($puzzleGrid => {
		const newGrid = $puzzleGrid.map(row => [...row]);
		userGrid.set(newGrid);
	});

	return {
		subscribe: userGrid.subscribe,

		/**
		 * 替换整个网格
		 */
		replace(newGrid) {
			const cloned = newGrid.map(row => [...row]);
			userGrid.set(cloned);
		},

		/**
		 * 设置指定位置的值
		 */
		set(pos, value) {
			userGrid.update($userGrid => {
				$userGrid[pos.y][pos.x] = value;
				return $userGrid;
			});
		},

		/**
		 * 应用提示（使用求解器）
		 */
		applyHint(pos, value = null) {
			hints.useHint();
			userGrid.update($userGrid => {
				const solvedValue = value !== null 
					? value 
					: solver.getSolutionAt($userGrid, pos.x, pos.y);
				$userGrid[pos.y][pos.x] = solvedValue || $userGrid[pos.y][pos.x];
				return $userGrid;
			});
		},
	};
}

// 导入题目网格（延迟导入避免循环依赖）
import { puzzleGrid } from './puzzle-grid.js';

// 创建默认实例（保持向后兼容）
export const userGrid = createUserGrid(puzzleGrid);

// 导出工厂函数（供需要自定义的场景使用）
export { createUserGrid };