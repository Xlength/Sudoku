import { SUDOKU_SIZE, BOX_SIZE } from '@sudoku/constants';

/**
 * 单数查找器 - 负责查找Naked Single和Hidden Single
 * 
 * OOAD设计原则：
 * 1. 单一职责：专门负责查找单数（Naked Single和Hidden Single）
 * 2. 代码复用：被HintStrategyManager和NextStepProcessor共享使用
 */
class SingleFinder {
	/**
	 * 查找Naked Single（只有一个候选数的单元格）
	 * @param {number[][]} grid - 数独网格
	 * @param {Object} candidatesDict - 候选数字典
	 * @returns {Object|null} {position: {x,y}, value: number}
	 */
	findNakedSingle(grid, candidatesDict) {
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				if (grid[y][x] !== 0) continue;
				const key = `${x},${y}`;
				const cellCandidates = candidatesDict[key] || [];
				if (cellCandidates.length === 1) {
					return {
						position: { x, y },
						value: cellCandidates[0],
					};
				}
			}
		}
		return null;
	}

	/**
	 * 查找Hidden Single（某个数字在行/列/宫中只能出现在一个位置）
	 * @param {number[][]} grid - 数独网格
	 * @param {Object} candidatesDict - 候选数字典
	 * @returns {Object|null} {position: {x,y}, value: number, strategy: string, explanation: string}
	 */
	findHiddenSingle(grid, candidatesDict) {
		// 检查行
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			const positionsByNumber = Array.from({ length: SUDOKU_SIZE + 1 }, () => []);
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				if (grid[y][x] === 0) {
					const key = `${x},${y}`;
					const cellCandidates = candidatesDict[key] || [];
					cellCandidates.forEach(candidate => {
						positionsByNumber[candidate].push({ x, y });
					});
				}
			}
			for (let value = 1; value <= SUDOKU_SIZE; value++) {
				if (positionsByNumber[value].length === 1) {
					const pos = positionsByNumber[value][0];
					return {
						position: pos,
						value,
						strategy: 'Hidden Single (Row)',
						explanation: `在行 ${y + 1} 中，数字 ${value} 只能出现在列 ${pos.x + 1}`,
					};
				}
			}
		}

		// 检查列
		for (let x = 0; x < SUDOKU_SIZE; x++) {
			const positionsByNumber = Array.from({ length: SUDOKU_SIZE + 1 }, () => []);
			for (let y = 0; y < SUDOKU_SIZE; y++) {
				if (grid[y][x] === 0) {
					const key = `${x},${y}`;
					const cellCandidates = candidatesDict[key] || [];
					cellCandidates.forEach(candidate => {
						positionsByNumber[candidate].push({ x, y });
					});
				}
			}
			for (let value = 1; value <= SUDOKU_SIZE; value++) {
				if (positionsByNumber[value].length === 1) {
					const pos = positionsByNumber[value][0];
					return {
						position: pos,
						value,
						strategy: 'Hidden Single (Column)',
						explanation: `在列 ${x + 1} 中，数字 ${value} 只能出现在行 ${pos.y + 1}`,
					};
				}
			}
		}

		// 检查宫
		for (let boxRow = 0; boxRow < BOX_SIZE; boxRow++) {
			for (let boxCol = 0; boxCol < BOX_SIZE; boxCol++) {
				const positionsByNumber = Array.from({ length: SUDOKU_SIZE + 1 }, () => []);
				for (let y = boxRow * BOX_SIZE; y < (boxRow + 1) * BOX_SIZE; y++) {
					for (let x = boxCol * BOX_SIZE; x < (boxCol + 1) * BOX_SIZE; x++) {
						if (grid[y][x] === 0) {
							const key = `${x},${y}`;
							const cellCandidates = candidatesDict[key] || [];
							cellCandidates.forEach(candidate => {
								positionsByNumber[candidate].push({ x, y });
							});
						}
					}
				}
				for (let value = 1; value <= SUDOKU_SIZE; value++) {
					if (positionsByNumber[value].length === 1) {
						const pos = positionsByNumber[value][0];
						return {
							position: pos,
							value,
							strategy: 'Hidden Single (Box)',
							explanation: `在宫 (${boxCol + 1},${boxRow + 1}) 中，数字 ${value} 只能出现在位置 (${pos.x + 1},${pos.y + 1})`,
						};
					}
				}
			}
		}

		return null;
	}
}

export const singleFinder = new SingleFinder();
