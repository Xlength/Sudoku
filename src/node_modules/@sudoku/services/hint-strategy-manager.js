import { strategyRegistry } from '../strategies/strategy-registry.js';
import { candidateManager } from './candidate-manager.js';
import { singleFinder } from './single-finder.js';
import { get } from 'svelte/store';
import { userGrid } from '../stores/grid.js';
import { candidates } from '../stores/candidates.js';
import { SUDOKU_SIZE } from '@sudoku/constants';

/**
 * 提示策略管理器 - 专门用于提示功能
 * 通过补齐候选数并执行多步循环，直到找到可以确定的数字
 * 
 * OOAD设计原则：
 * 1. 单一职责：专门负责提示功能的策略执行
 * 2. 适配器模式：将"删候选数"策略适配为"填数字"结果
 * 3. 开闭原则：可以扩展新的提示策略而不修改现有代码
 */
class HintStrategyManager {
	constructor() {
		this.strategies = strategyRegistry.getAll();
	}

	/**
	 * 执行策略并返回可以填数字的提示
	 * 补齐候选数后执行多步循环，直到找到可确定的数字
	 * @returns {Object|null} 提示结果 {position: {x,y}, value: number, strategy: string, explanation: string, autoAddedCandidates: Set}
	 */
	executeStrategies() {
		const grid = get(userGrid);
		const originalCandidates = get(candidates);
		
		// 记录用户原有的候选数（用于后续恢复）
		const userCandidates = new Set(Object.keys(originalCandidates || {}));
		
		// 补齐所有空格的候选数（但保留用户已有的）
		const fullCandidates = this.completeCandidates(grid, originalCandidates);
		
		// 记录我们自动添加的候选数
		const autoAddedCandidates = new Set();
		Object.keys(fullCandidates).forEach(key => {
			if (!userCandidates.has(key)) {
				autoAddedCandidates.add(key);
			}
		});

		// 执行多步循环，直到找到可以确定的数字
		const result = this.processUntilSolved(grid, fullCandidates);
		
		if (result) {
			return {
				position: result.position,
				value: result.value,
				strategy: result.strategy,
				explanation: result.explanation,
				candidates: [result.value],
				autoAddedCandidates, // 记录自动添加的候选数，用于后续清除
			};
		}

		return null;
	}

	/**
	 * 补齐候选数：为所有空格计算候选数，但保留用户已有的
	 */
	completeCandidates(grid, existingCandidates) {
		const completed = JSON.parse(JSON.stringify(existingCandidates || {}));
		
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				if (grid[y][x] === 0) {
					const key = `${x},${y}`;
					// 如果用户没有添加候选数，则自动计算
					if (!completed[key] || completed[key].length === 0) {
						completed[key] = candidateManager.getCandidatesForCell(grid, x, y);
					}
				}
			}
		}
		
		return completed;
	}

	/**
	 * 执行多步循环，直到找到可以确定的数字
	 */
	processUntilSolved(initialGrid, initialCandidates) {
		const grid = initialGrid.map(row => [...row]); // 深拷贝网格
		let currentCandidates = JSON.parse(JSON.stringify(initialCandidates)); // 深拷贝候选数
		
		let loopCount = 0;
		const maxLoops = 100; // 防止无限循环
		const steps = []; // 记录执行的步骤，用于生成说明

		while (loopCount < maxLoops) {
			let changed = false;

			// 步骤1: Check for solved cells - 删除冲突的候选数
			const step1Eliminations = candidateManager.checkForSolvedCells(grid, currentCandidates);
			if (step1Eliminations.length > 0) {
				step1Eliminations.forEach(elim => {
					const key = `${elim.position.x},${elim.position.y}`;
					if (currentCandidates[key]) {
						currentCandidates[key] = currentCandidates[key].filter(c => !elim.removed.includes(c));
						if (currentCandidates[key].length === 0) {
							delete currentCandidates[key];
						}
					}
				});
				changed = true;
				if (steps.length === 0) {
					steps.push('Check for solved cells');
				}
			}

			// 步骤2: Show Possibles - 确定只有一个候选数的格子
			const step2Solved = candidateManager.showPossibles(grid, currentCandidates);
			if (step2Solved.length > 0) {
				// 找到可以确定的数字，返回第一个
				const firstSolved = step2Solved[0];
				let strategy = 'Show Possibles (Naked Singles)';
				let explanation = `找到了 ${step2Solved.length} 个只有一个候选数的单元格。`;
				
				if (steps.length > 0) {
					explanation = `经过 ${steps.join(' → ')} → Show Possibles 后，单元格 (${firstSolved.position.x + 1},${firstSolved.position.y + 1}) 只剩下候选数 ${firstSolved.value}。`;
				} else {
					explanation = `单元格 (${firstSolved.position.x + 1},${firstSolved.position.y + 1}) 只有一个候选数 ${firstSolved.value}。`;
				}
				
				return {
					position: firstSolved.position,
					value: firstSolved.value,
					strategy,
					explanation,
				};
			}

			// 步骤3: 执行策略，查找可以删除候选数的策略
			for (const strategy of this.strategies) {
				try {
					const result = strategy.execute(grid, currentCandidates);
					if (result && result.type === 'eliminate' && result.eliminations && result.eliminations.length > 0) {
						// 应用删除操作
						result.eliminations.forEach(elim => {
							const key = `${elim.position.x},${elim.position.y}`;
							if (currentCandidates[key]) {
								currentCandidates[key] = currentCandidates[key].filter(c => !elim.removed.includes(c));
								if (currentCandidates[key].length === 0) {
									delete currentCandidates[key];
								}
							}
						});
						
						changed = true;
						steps.push(result.strategy);
						
						// 检查删除后是否有单元格只剩下一个候选数
						const nakedSingle = singleFinder.findNakedSingle(grid, currentCandidates);
						if (nakedSingle) {
							let explanation = `经过 ${steps.join(' → ')} 后，单元格 (${nakedSingle.position.x + 1},${nakedSingle.position.y + 1}) 只剩下候选数 ${nakedSingle.value}。`;
							return {
								position: nakedSingle.position,
								value: nakedSingle.value,
								strategy: result.strategy,
								explanation,
							};
						}
						
						// 检查是否有Hidden Single
						const hiddenSingle = singleFinder.findHiddenSingle(grid, currentCandidates);
						if (hiddenSingle) {
							let explanation = `经过 ${steps.join(' → ')} 后，${hiddenSingle.explanation}，因此单元格 (${hiddenSingle.position.x + 1},${hiddenSingle.position.y + 1}) 只能填入 ${hiddenSingle.value}。`;
							return {
								position: hiddenSingle.position,
								value: hiddenSingle.value,
								strategy: result.strategy,
								explanation,
							};
						}
						
						// 找到策略后，跳出策略循环，继续三步循环
						break;
					}
				} catch (error) {
					console.warn(`Strategy ${strategy.id} execution error:`, error);
					continue;
				}
			}

			// 如果本轮没有变化，停止循环
			if (!changed) {
				break;
			}

			loopCount++;
		}

		return null;
	}

}

export const hintStrategyManager = new HintStrategyManager();
