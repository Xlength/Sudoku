import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';
import { candidateCalculator } from './candidate-calculator.js';

/**
 * 提示引擎 - 负责生成数独求解提示
 * 
 * OOAD设计原则：
 * 1. 单一职责：专门负责提示生成
 * 2. 依赖注入：使用候选数计算器服务，避免代码重复
 * 3. 开闭原则：可以扩展新的提示策略而不修改现有代码
 */
class HintEngine {
	constructor(calculator = candidateCalculator) {
		this.candidateCalculator = calculator;
	}

	/**
	 * 获取单元格的候选数
	 * 委托给候选数计算器
	 */
	getCandidates(grid, x, y) {
		return this.candidateCalculator.calculateForCell(grid, x, y);
	}

	findNakedSingle(grid) {
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const candidates = this.getCandidates(grid, x, y);

				if (candidates.length === 1) {
					return {
						position: { x, y },
						value: candidates[0],
						strategy: 'Single Candidate',
						explanation: `Cell (${x + 1},${y + 1}) only allows number ${candidates[0]} because all other digits are blocked in its row, column or box.`,
					};
				}
			}
		}

		return null;
	}

	findHiddenSingle(grid) {
		// Rows
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			const positionsByNumber = Array.from({ length: SUDOKU_SIZE + 1 }, () => []);

			for (let x = 0; x < SUDOKU_SIZE; x++) {
				this.getCandidates(grid, x, y).forEach(candidate => {
					positionsByNumber[candidate].push({ x, y });
				});
			}

			for (let value = 1; value <= SUDOKU_SIZE; value++) {
				if (positionsByNumber[value].length === 1) {
					const pos = positionsByNumber[value][0];
					return {
						position: pos,
						value,
						strategy: 'Hidden Single (Row)',
						explanation: `In row ${y + 1}, the number ${value} can only fit in column ${pos.x + 1}.`,
					};
				}
			}
		}

		// Columns
		for (let x = 0; x < SUDOKU_SIZE; x++) {
			const positionsByNumber = Array.from({ length: SUDOKU_SIZE + 1 }, () => []);

			for (let y = 0; y < SUDOKU_SIZE; y++) {
				this.getCandidates(grid, x, y).forEach(candidate => {
					positionsByNumber[candidate].push({ x, y });
				});
			}

			for (let value = 1; value <= SUDOKU_SIZE; value++) {
				if (positionsByNumber[value].length === 1) {
					const pos = positionsByNumber[value][0];
					return {
						position: pos,
						value,
						strategy: 'Hidden Single (Column)',
						explanation: `In column ${x + 1}, the number ${value} only fits in row ${pos.y + 1}.`,
					};
				}
			}
		}

		// Boxes
		for (let boxRow = 0; boxRow < BOX_SIZE; boxRow++) {
			for (let boxCol = 0; boxCol < BOX_SIZE; boxCol++) {
				const positionsByNumber = Array.from({ length: SUDOKU_SIZE + 1 }, () => []);

				for (let y = boxRow * BOX_SIZE; y < (boxRow + 1) * BOX_SIZE; y++) {
					for (let x = boxCol * BOX_SIZE; x < (boxCol + 1) * BOX_SIZE; x++) {
						this.getCandidates(grid, x, y).forEach(candidate => {
							positionsByNumber[candidate].push({ x, y });
						});
					}
				}

				for (let value = 1; value <= SUDOKU_SIZE; value++) {
					if (positionsByNumber[value].length === 1) {
						const pos = positionsByNumber[value][0];
						return {
							position: pos,
							value,
							strategy: 'Hidden Single (Box)',
							explanation: `In box (${boxCol + 1},${boxRow + 1}), the number ${value} only fits at (${pos.x + 1},${pos.y + 1}).`,
						};
					}
				}
			}
		}

		return null;
	}

	getHint(grid) {
		const logicalHint = this.findNakedSingle(grid) || this.findHiddenSingle(grid);

		if (logicalHint) {
			return {
				...logicalHint,
				candidates: this.getCandidates(grid, logicalHint.position.x, logicalHint.position.y),
			};
		}

		return null;
	}
}

export const hintEngine = new HintEngine();
