import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';

class HintEngine {
	getCandidates(grid, x, y) {
		if (grid[y][x] !== 0) return [];

		const present = new Set();

		for (let i = 0; i < SUDOKU_SIZE; i++) {
			present.add(grid[y][i]);
			present.add(grid[i][x]);
		}

		const startRow = Math.floor(y / BOX_SIZE) * BOX_SIZE;
		const startCol = Math.floor(x / BOX_SIZE) * BOX_SIZE;

		for (let row = startRow; row < startRow + BOX_SIZE; row++) {
			for (let col = startCol; col < startCol + BOX_SIZE; col++) {
				present.add(grid[row][col]);
			}
		}

		const candidates = [];
		for (let num = 1; num <= SUDOKU_SIZE; num++) {
			if (!present.has(num)) candidates.push(num);
		}

		return candidates;
	}

	findNakedSingle(grid) {
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const candidates = this.getCandidates(grid, x, y);

				if (candidates.length === 1) {
					return {
						position: { x, y },
						value: candidates[0],
						strategy: 'Single Candidate',
						explanation: `Cell (${x + 1},${y + 1}) only allows number ${candidates[0]} because all other digits are blocked in its row, column or box.`,
					};
				}
			}
		}

		return null;
	}

	findHiddenSingle(grid) {
		// Rows
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			const positionsByNumber = Array.from({ length: SUDOKU_SIZE + 1 }, () => []);

			for (let x = 0; x < SUDOKU_SIZE; x++) {
				this.getCandidates(grid, x, y).forEach(candidate => {
					positionsByNumber[candidate].push({ x, y });
				});
			}

			for (let value = 1; value <= SUDOKU_SIZE; value++) {
				if (positionsByNumber[value].length === 1) {
					const pos = positionsByNumber[value][0];
					return {
						position: pos,
						value,
						strategy: 'Hidden Single (Row)',
						explanation: `In row ${y + 1}, the number ${value} can only fit in column ${pos.x + 1}.`,
					};
				}
			}
		}

		// Columns
		for (let x = 0; x < SUDOKU_SIZE; x++) {
			const positionsByNumber = Array.from({ length: SUDOKU_SIZE + 1 }, () => []);

			for (let y = 0; y < SUDOKU_SIZE; y++) {
				this.getCandidates(grid, x, y).forEach(candidate => {
					positionsByNumber[candidate].push({ x, y });
				});
			}

			for (let value = 1; value <= SUDOKU_SIZE; value++) {
				if (positionsByNumber[value].length === 1) {
					const pos = positionsByNumber[value][0];
					return {
						position: pos,
						value,
						strategy: 'Hidden Single (Column)',
						explanation: `In column ${x + 1}, the number ${value} only fits in row ${pos.y + 1}.`,
					};
				}
			}
		}

		// Boxes
		for (let boxRow = 0; boxRow < BOX_SIZE; boxRow++) {
			for (let boxCol = 0; boxCol < BOX_SIZE; boxCol++) {
				const positionsByNumber = Array.from({ length: SUDOKU_SIZE + 1 }, () => []);

				for (let y = boxRow * BOX_SIZE; y < (boxRow + 1) * BOX_SIZE; y++) {
					for (let x = boxCol * BOX_SIZE; x < (boxCol + 1) * BOX_SIZE; x++) {
						this.getCandidates(grid, x, y).forEach(candidate => {
							positionsByNumber[candidate].push({ x, y });
						});
					}
				}

				for (let value = 1; value <= SUDOKU_SIZE; value++) {
					if (positionsByNumber[value].length === 1) {
						const pos = positionsByNumber[value][0];
						return {
							position: pos,
							value,
							strategy: 'Hidden Single (Box)',
							explanation: `In box (${boxCol + 1},${boxRow + 1}), the number ${value} only fits at (${pos.x + 1},${pos.y + 1}).`,
						};
					}
				}
			}
		}

		return null;
	}

	getHint(grid) {
		const logicalHint = this.findNakedSingle(grid) || this.findHiddenSingle(grid);

		if (logicalHint) {
			return {
				...logicalHint,
				candidates: this.getCandidates(grid, logicalHint.position.x, logicalHint.position.y),
			};
		}

		return null;
	}
}

export const hintEngine = new HintEngine();
