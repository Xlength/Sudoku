import { BaseStrategy } from '../strategies/base-strategy.js';

/**
 * 策略验证器 - 确保策略算法的正确性和独立性
 * 
 * OOAD设计原则：
 * 1. 单一职责：专门负责验证策略的正确性
 * 2. 依赖倒置：依赖策略接口而非具体实现
 * 3. 开闭原则：验证逻辑可以扩展而不修改现有代码
 */
class StrategyValidator {
	/**
	 * 验证策略结果的正确性
	 * 
	 * 验证步骤：
	 * 1. 检查结果格式是否正确
	 * 2. 检查类型（solve或eliminate）
	 * 3. 验证位置和值（solve类型）
	 * 4. 验证删除操作（eliminate类型）
	 */
	validateResult(grid, result, candidatesDict = null) {
		if (!result) return { valid: false, reason: 'No result returned' };

		// 检查类型
		if (result.type !== 'solve' && result.type !== 'eliminate') {
			return { valid: false, reason: 'Invalid result type' };
		}

		// 验证solve类型
		if (result.type === 'solve') {
			if (!result.position || typeof result.position.x !== 'number' || typeof result.position.y !== 'number') {
				return { valid: false, reason: 'Invalid position' };
			}

			if (typeof result.value !== 'number' || result.value < 1 || result.value > 9) {
				return { valid: false, reason: 'Invalid value' };
			}

			const { x, y } = result.position;

			if (x < 0 || x >= 9 || y < 0 || y >= 9) {
				return { valid: false, reason: 'Position out of bounds' };
			}

			if (grid[y][x] !== 0) {
				return { valid: false, reason: 'Cell already filled' };
			}

			const baseStrategy = new BaseStrategy('', 0);
			if (!baseStrategy.validateResult(grid, result.position, result.value)) {
				return { valid: false, reason: 'Value violates Sudoku rules' };
			}

			return { valid: true };
		}

		// 验证eliminate类型
		if (result.type === 'eliminate') {
			if (!result.eliminations || !Array.isArray(result.eliminations)) {
				return { valid: false, reason: 'Invalid eliminations array' };
			}

			if (result.eliminations.length === 0) {
				return { valid: false, reason: 'Empty eliminations array' };
			}

			// 验证每个删除操作
			for (const elim of result.eliminations) {
				if (!elim.position || typeof elim.position.x !== 'number' || typeof elim.position.y !== 'number') {
					return { valid: false, reason: 'Invalid elimination position' };
				}

				const { x, y } = elim.position;

				if (x < 0 || x >= 9 || y < 0 || y >= 9) {
					return { valid: false, reason: 'Elimination position out of bounds' };
				}

				if (grid[y][x] !== 0) {
					return { valid: false, reason: 'Cannot eliminate from filled cell' };
				}

				if (!elim.removed || !Array.isArray(elim.removed) || elim.removed.length === 0) {
					return { valid: false, reason: 'Invalid removed candidates' };
				}

				// 验证要删除的候选数是否真的存在于该单元格
				if (candidatesDict) {
					const key = `${x},${y}`;
					const cellCandidates = candidatesDict[key] || [];
					for (const removed of elim.removed) {
						if (!cellCandidates.includes(removed)) {
							return { valid: false, reason: `Candidate ${removed} not in cell (${x},${y})` };
						}
					}
				}
			}

			return { valid: true };
		}

		return { valid: false, reason: 'Unknown result type' };
	}

	/**
	 * 验证策略执行不会修改原始网格和候选数
	 * 确保算法独立性
	 */
	validateImmutability(originalGrid, originalCandidates, strategy) {
		const gridBefore = JSON.stringify(originalGrid);
		const candidatesBefore = JSON.stringify(originalCandidates);

		try {
			strategy.execute(originalGrid, originalCandidates);
		} catch (error) {
			return { valid: false, reason: `Strategy execution error: ${error.message}` };
		}

		const gridAfter = JSON.stringify(originalGrid);
		const candidatesAfter = JSON.stringify(originalCandidates);

		if (gridBefore !== gridAfter) {
			return { valid: false, reason: 'Strategy modified original grid' };
		}

		if (candidatesBefore !== candidatesAfter) {
			return { valid: false, reason: 'Strategy modified original candidates' };
		}

		return { valid: true };
	}

	/**
	 * 综合验证：检查策略的正确性和独立性
	 */
	validateStrategy(grid, strategy, candidatesDict = null) {
		const immutabilityCheck = this.validateImmutability(grid, candidatesDict, strategy);
		if (!immutabilityCheck.valid) {
			return immutabilityCheck;
		}

		const result = strategy.execute(grid, candidatesDict);
		if (!result) {
			return { valid: true, applicable: false };
		}

		const resultCheck = this.validateResult(grid, result, candidatesDict);
		if (!resultCheck.valid) {
			return { valid: false, reason: resultCheck.reason };
		}

		return { valid: true, applicable: true, result };
	}
}

export const strategyValidator = new StrategyValidator();
