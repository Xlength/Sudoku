import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';
import { candidateCalculator } from './candidate-calculator.js';

/**
 * 候选数管理器 - 负责候选数的自动填充和管理
 * 
 * OOAD设计原则：
 * 1. 单一职责：专门负责候选数的管理和维护
 * 2. 依赖注入：使用候选数计算器服务，避免代码重复
 * 3. 组合优于继承：通过组合候选数计算器来实现功能
 */
class CandidateManager {
	constructor(calculator = candidateCalculator) {
		this.candidateCalculator = calculator;
	}

	/**
	 * 根据数独基本规则，为所有空位计算候选数
	 * @param {number[][]} grid - 数独网格
	 * @returns {Object} 候选数字典 { "x,y": [1,2,3], ... }
	 */
	calculateAllCandidates(grid) {
		return this.candidateCalculator.calculateAllAsDict(grid);
	}

	/**
	 * 获取单个单元格的候选数
	 * 委托给候选数计算器
	 */
	getCandidatesForCell(grid, x, y) {
		return this.candidateCalculator.calculateForCell(grid, x, y);
	}

	/**
	 * Check for solved cells - 删除冲突的候选数
	 * 检查已确定的格子，删除同行/列/宫中其他格子的冲突候选数
	 * @param {number[][]} grid - 数独网格
	 * @param {Object} candidates - 当前候选数字典
	 * @returns {Array} 删除操作列表 [{position: {x,y}, removed: [1,2,3]}, ...]
	 */
	checkForSolvedCells(grid, candidates) {
		const eliminations = [];

		for (let y = 0; y < SUDOKU_SIZE; y++) {
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const value = grid[y][x];
				if (value === 0) continue;

				// 检查行
				for (let i = 0; i < SUDOKU_SIZE; i++) {
					if (i !== x && grid[y][i] === 0) {
						const key = `${i},${y}`;
						if (candidates[key] && candidates[key].includes(value)) {
							if (!eliminations.find(e => e.position.x === i && e.position.y === y)) {
								eliminations.push({
									position: { x: i, y },
									removed: [value],
								});
							} else {
								const existing = eliminations.find(e => e.position.x === i && e.position.y === y);
								if (!existing.removed.includes(value)) {
									existing.removed.push(value);
								}
							}
						}
					}
				}

				// 检查列
				for (let i = 0; i < SUDOKU_SIZE; i++) {
					if (i !== y && grid[i][x] === 0) {
						const key = `${x},${i}`;
						if (candidates[key] && candidates[key].includes(value)) {
							if (!eliminations.find(e => e.position.x === x && e.position.y === i)) {
								eliminations.push({
									position: { x, y: i },
									removed: [value],
								});
							} else {
								const existing = eliminations.find(e => e.position.x === x && e.position.y === i);
								if (!existing.removed.includes(value)) {
									existing.removed.push(value);
								}
							}
						}
					}
				}

				// 检查宫
				const startRow = Math.floor(y / BOX_SIZE) * BOX_SIZE;
				const startCol = Math.floor(x / BOX_SIZE) * BOX_SIZE;
				for (let row = startRow; row < startRow + BOX_SIZE; row++) {
					for (let col = startCol; col < startCol + BOX_SIZE; col++) {
						if ((row !== y || col !== x) && grid[row][col] === 0) {
							const key = `${col},${row}`;
							if (candidates[key] && candidates[key].includes(value)) {
								if (!eliminations.find(e => e.position.x === col && e.position.y === row)) {
									eliminations.push({
										position: { x: col, y: row },
										removed: [value],
									});
								} else {
									const existing = eliminations.find(e => e.position.x === col && e.position.y === row);
									if (!existing.removed.includes(value)) {
										existing.removed.push(value);
									}
								}
							}
						}
					}
				}
			}
		}

		return eliminations;
	}

	/**
	 * Show Possibles - 查找只有一个候选数的格子并确定下来
	 * @param {number[][]} grid - 数独网格
	 * @param {Object} candidates - 当前候选数字典
	 * @returns {Array} 确定操作列表 [{position: {x,y}, value: number}, ...]
	 */
	showPossibles(grid, candidates) {
		const solved = [];

		for (let y = 0; y < SUDOKU_SIZE; y++) {
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				if (grid[y][x] !== 0) continue;

				const key = `${x},${y}`;
				const cellCandidates = candidates[key] || [];

				if (cellCandidates.length === 1) {
					solved.push({
						position: { x, y },
						value: cellCandidates[0],
					});
				}
			}
		}

		return solved;
	}
}

export const candidateManager = new CandidateManager();
