import { candidateManager } from './candidate-manager.js';
import { strategyRegistry } from '../strategies/strategy-registry.js';
import { get } from 'svelte/store';
import { userGrid } from '../stores/grid.js';
import { candidates } from '../stores/candidates.js';

/**
 * Next Step 处理器 - 实现三步循环处理逻辑
 */
class NextStepProcessor {
	/**
	 * 执行一步处理
	 * 按照三步循环：Check for solved cells -> Show Possibles -> Strategies
	 * 如果某一步没有可操作项，自动跳过到下一步并显示跳过信息
	 * @returns {Object} 处理结果
	 */
	processStep() {
		const grid = get(userGrid);
		let currentCandidates = get(candidates);

		// 步骤1: Check for solved cells - 删除冲突的候选数
		const step1Eliminations = candidateManager.checkForSolvedCells(grid, currentCandidates);
		if (step1Eliminations.length > 0) {
			return {
				type: 'eliminate',
				step: 'Check for solved cells',
				eliminations: step1Eliminations,
				strategy: 'Check for solved cells',
				explanation: `根据已确定的数字，删除了 ${step1Eliminations.length} 个单元格中的冲突候选数。`,
			};
		}

		// 步骤1无可操作，自动跳过并显示信息
		// 步骤2: Show Possibles - 确定只有一个候选数的格子
		const step2Solved = candidateManager.showPossibles(grid, currentCandidates);
		if (step2Solved.length > 0) {
			return {
				type: 'solve',
				step: 'Show Possibles',
				solved: step2Solved,
				strategy: 'Show Possibles (Naked Singles)',
				explanation: `找到了 ${step2Solved.length} 个只有一个候选数的单元格，可以确定下来。`,
				skipped: ['Check for solved cells'],
			};
		}

		// 步骤2无可操作，自动跳过并显示信息
		// 步骤3: 优先尝试 Hidden Singles（策略1），不纳入并行比较；若无结果，再并行比较其它策略选最优
		const strategies = strategyRegistry.getAll();

		// 3.1 优先执行 Hidden Singles（id=1）
		const hiddenSingles = strategies.find((s) => s.id === 1);
		if (hiddenSingles) {
			try {
				const hsResult = hiddenSingles.execute(grid, currentCandidates);
				if (hsResult && hsResult.type === 'eliminate' && hsResult.eliminations && hsResult.eliminations.length > 0) {
					const hsTotal = hsResult.eliminations.reduce((sum, elim) => sum + elim.removed.length, 0);
					return {
						type: 'eliminate',
						step: 'Strategy',
						eliminations: hsResult.eliminations,
						strategy: hsResult.strategy,
						explanation: `${hsResult.explanation}（Hidden Singles 具有最高优先级，直接采用；本次删除了 ${hsTotal} 个候选数）`,
						strategyId: hiddenSingles.id,
						skipped: ['Check for solved cells', 'Show Possibles'],
					};
				}
			} catch (error) {
				console.warn(`Strategy ${hiddenSingles.id} execution error:`, error);
			}
		}

		// 3.2 并行比较其它策略（排除 Hidden Singles），选择删除候选数最多的策略
		const strategyResults = [];
		for (const strategy of strategies) {
			if (strategy.id === 1) continue;
			try {
				const result = strategy.execute(grid, currentCandidates);
				if (result && result.type === 'eliminate' && result.eliminations && result.eliminations.length > 0) {
					const totalEliminations = result.eliminations.reduce((sum, elim) => sum + elim.removed.length, 0);
					strategyResults.push({
						strategy,
						result,
						totalEliminations,
						strategyId: strategy.id,
					});
				}
			} catch (error) {
				console.warn(`Strategy ${strategy.id} execution error:`, error);
				continue;
			}
		}

		if (strategyResults.length > 0) {
			strategyResults.sort((a, b) => b.totalEliminations - a.totalEliminations);
			const bestStrategy = strategyResults[0];

			return {
				type: 'eliminate',
				step: 'Strategy',
				eliminations: bestStrategy.result.eliminations,
				strategy: bestStrategy.result.strategy,
				explanation: `${bestStrategy.result.explanation}（Hidden Singles 无可用结果；从 ${strategyResults.length} 个可用策略中选择，此策略删除了 ${bestStrategy.totalEliminations} 个候选数，是最优选择）`,
				strategyId: bestStrategy.strategyId,
				skipped: ['Check for solved cells', 'Show Possibles'],
			};
		}

		// 检查数独是否已经完成
		let isComplete = true;
		for (let y = 0; y < 9; y++) {
			for (let x = 0; x < 9; x++) {
				if (grid[y][x] === 0) {
					isComplete = false;
					break;
				}
			}
			if (!isComplete) break;
		}

		if (isComplete) {
			return {
				type: 'complete',
				step: 'Complete',
				strategy: 'Sudoku Solved',
				explanation: '数独已经完成！',
			};
		}

		// 三步都无可操作，但数独未完成
		// 返回跳过信息，提示用户继续点击 Next Step 会重新循环
		return {
			type: 'skip',
			step: 'All Steps Skipped',
			strategy: '循环完成',
			explanation: 'Check for solved cells: 无可操作单元格，跳过。Show Possibles: 无可操作单元格，跳过。策略: 无可操作单元格，跳过。请继续点击 Next Step 重新循环。',
			skipped: ['Check for solved cells', 'Show Possibles', 'Strategies'],
		};
	}

}

export const nextStepProcessor = new NextStepProcessor();
