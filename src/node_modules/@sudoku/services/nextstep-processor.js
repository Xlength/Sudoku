import { candidateManager } from './candidate-manager.js';
import { strategyRegistry } from '../strategies/strategy-registry.js';
import { get } from 'svelte/store';
import { userGrid } from '../stores/grid.js';
import { candidates } from '../stores/candidates.js';

/**
 * Next Step 处理器 - 实现三步循环处理逻辑
 */
class NextStepProcessor {
	/**
	 * 执行一步处理
	 * 按照三步循环：Check for solved cells -> Show Possibles -> Strategies
	 * 如果某一步没有可操作项，自动跳过到下一步并显示跳过信息
	 * @returns {Object} 处理结果
	 */
	processStep() {
		const grid = get(userGrid);
		let currentCandidates = get(candidates);

		// 步骤1: Check for solved cells - 删除冲突的候选数
		const step1Eliminations = candidateManager.checkForSolvedCells(grid, currentCandidates);
		if (step1Eliminations.length > 0) {
			return {
				type: 'eliminate',
				step: 'Check for solved cells',
				eliminations: step1Eliminations,
				strategy: 'Check for solved cells',
				explanation: `根据已确定的数字，删除了 ${step1Eliminations.length} 个单元格中的冲突候选数。`,
			};
		}

		// 步骤1无可操作，自动跳过并显示信息
		// 步骤2: Show Possibles - 确定只有一个候选数的格子
		const step2Solved = candidateManager.showPossibles(grid, currentCandidates);
		if (step2Solved.length > 0) {
			return {
				type: 'solve',
				step: 'Show Possibles',
				solved: step2Solved,
				strategy: 'Show Possibles (Naked Singles)',
				explanation: `找到了 ${step2Solved.length} 个只有一个候选数的单元格，可以确定下来。`,
				skipped: ['Check for solved cells'],
			};
		}

		// 步骤2无可操作，自动跳过并显示信息
		// 步骤3: 执行41种策略，查找可以删除候选数的策略
		const strategies = strategyRegistry.getAll();
		for (const strategy of strategies) {
			try {
				const result = strategy.execute(grid, currentCandidates);
				if (result && result.type === 'eliminate' && result.eliminations && result.eliminations.length > 0) {
					// 找到可以删除候选数的策略，应用所有可删除的点
					return {
						type: 'eliminate',
						step: 'Strategy',
						eliminations: result.eliminations,
						strategy: result.strategy,
						explanation: result.explanation,
						strategyId: strategy.id,
						skipped: ['Check for solved cells', 'Show Possibles'],
					};
				}
			} catch (error) {
				// 策略执行出错，继续下一个策略
				console.warn(`Strategy ${strategy.id} execution error:`, error);
				continue;
			}
		}

		// 检查数独是否已经完成
		let isComplete = true;
		for (let y = 0; y < 9; y++) {
			for (let x = 0; x < 9; x++) {
				if (grid[y][x] === 0) {
					isComplete = false;
					break;
				}
			}
			if (!isComplete) break;
		}

		if (isComplete) {
			return {
				type: 'complete',
				step: 'Complete',
				strategy: 'Sudoku Solved',
				explanation: '数独已经完成！',
			};
		}

		// 三步都无可操作，但数独未完成
		// 返回跳过信息，提示用户继续点击 Next Step 会重新循环
		return {
			type: 'skip',
			step: 'All Steps Skipped',
			strategy: '循环完成',
			explanation: 'Check for solved cells: 无可操作单元格，跳过。Show Possibles: 无可操作单元格，跳过。策略: 无可操作单元格，跳过。请继续点击 Next Step 重新循环。',
			skipped: ['Check for solved cells', 'Show Possibles', 'Strategies'],
		};
	}

}

export const nextStepProcessor = new NextStepProcessor();
