import { SUDOKU_SIZE } from '@sudoku/constants';
import { encodeSudoku, validateSencode } from '@sudoku/sencode';

/**
 * 题目导入策略接口
 * 使用策略模式支持多种导入格式
 * 
 * OOAD设计原则：
 * 1. 开闭原则：可以添加新的导入格式而不修改现有代码
 * 2. 依赖倒置：依赖抽象接口，不依赖具体实现
 */
class ImportStrategy {
	/**
	 * 检查输入是否匹配此策略
	 * @param {string} input - 输入字符串
	 * @returns {boolean}
	 */
	canHandle(input) {
		throw new Error('canHandle() must be implemented by subclass');
	}

	/**
	 * 解析输入并返回sencode
	 * @param {string} input - 输入字符串
	 * @returns {Object|null} {source: string, sencode: string}
	 */
	parse(input) {
		throw new Error('parse() must be implemented by subclass');
	}
}

/**
 * Sencode导入策略
 */
class SencodeImportStrategy extends ImportStrategy {
	canHandle(input) {
		return validateSencode(input.trim());
	}

	parse(input) {
		const trimmed = input.trim();
		if (this.canHandle(trimmed)) {
			return { source: 'sencode', sencode: trimmed };
		}
		return null;
	}
}

/**
 * SudokuWiki URL导入策略
 */
class SudokuWikiImportStrategy extends ImportStrategy {
	constructor() {
		super();
		this.GRID_PARAM_KEYS = ['grid', 'puzzle', 'board', 'bd'];
	}

	canHandle(input) {
		try {
			const url = new URL(input.trim());
			return this.GRID_PARAM_KEYS.some(key => url.searchParams.has(key));
		} catch {
			return false;
		}
	}

	parse(input) {
		try {
			const url = new URL(input.trim());
			const paramKey = this.GRID_PARAM_KEYS.find(key => url.searchParams.has(key));
			if (!paramKey) return null;

			const grid = this.parseGridString(url.searchParams.get(paramKey));
			if (!grid) return null;

			return {
				source: 'sudokuwiki',
				sencode: encodeSudoku(grid),
			};
		} catch {
			return null;
		}
	}

	parseGridString(gridString) {
		const digits = gridString.replace(/[^0-9.]/g, '');
		if (digits.length !== SUDOKU_SIZE * SUDOKU_SIZE) return null;

		const grid = [];
		let index = 0;

		for (let y = 0; y < SUDOKU_SIZE; y++) {
			grid[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const value = digits[index++];
				grid[y][x] = value === '.' ? 0 : parseInt(value, 10);
				if (Number.isNaN(grid[y][x])) grid[y][x] = 0;
			}
		}

		return grid;
	}
}

/**
 * 原始网格字符串导入策略
 */
class RawGridImportStrategy extends ImportStrategy {
	canHandle(input) {
		const digits = input.trim().replace(/[^0-9.]/g, '');
		return digits.length === SUDOKU_SIZE * SUDOKU_SIZE;
	}

	parse(input) {
		const grid = this.parseGridString(input.trim());
		if (!grid) return null;

		return {
			source: 'raw-grid',
			sencode: encodeSudoku(grid),
		};
	}

	parseGridString(gridString) {
		const digits = gridString.replace(/[^0-9.]/g, '');
		if (digits.length !== SUDOKU_SIZE * SUDOKU_SIZE) return null;

		const grid = [];
		let index = 0;

		for (let y = 0; y < SUDOKU_SIZE; y++) {
			grid[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const value = digits[index++];
				grid[y][x] = value === '.' ? 0 : parseInt(value, 10);
				if (Number.isNaN(grid[y][x])) grid[y][x] = 0;
			}
		}

		return grid;
	}
}

export const importStrategies = [
	new SencodeImportStrategy(),
	new SudokuWikiImportStrategy(),
	new RawGridImportStrategy(),
];
