import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';

/**
 * 候选数计算器 - 统一管理候选数的计算逻辑
 * 
 * OOAD设计原则：
 * 1. 单一职责：专门负责候选数的计算
 * 2. 开闭原则：可以扩展新的计算方式而不修改现有代码
 * 3. 依赖倒置：提供统一的接口，不依赖具体实现
 */
export class CandidateCalculator {
	/**
	 * 计算单个单元格的候选数
	 * @param {number[][]} grid - 数独网格
	 * @param {number} x - 列索引
	 * @param {number} y - 行索引
	 * @returns {number[]} 候选数数组
	 */
	calculateForCell(grid, x, y) {
		if (grid[y][x] !== 0) return [];

		const present = new Set();

		// 检查行和列
		for (let i = 0; i < SUDOKU_SIZE; i++) {
			if (grid[y][i] !== 0) present.add(grid[y][i]);
			if (grid[i][x] !== 0) present.add(grid[i][x]);
		}

		// 检查宫
		const startRow = Math.floor(y / BOX_SIZE) * BOX_SIZE;
		const startCol = Math.floor(x / BOX_SIZE) * BOX_SIZE;
		for (let row = startRow; row < startRow + BOX_SIZE; row++) {
			for (let col = startCol; col < startCol + BOX_SIZE; col++) {
				if (grid[row][col] !== 0) present.add(grid[row][col]);
			}
		}

		// 生成候选数
		const candidates = [];
		for (let num = 1; num <= SUDOKU_SIZE; num++) {
			if (!present.has(num)) candidates.push(num);
		}

		return candidates;
	}

	/**
	 * 计算所有单元格的候选数（矩阵格式）
	 * @param {number[][]} grid - 数独网格
	 * @returns {number[][][]} 候选数矩阵 [y][x] = [1,2,3,...]
	 */
	calculateAllAsMatrix(grid) {
		const candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				candidates[y][x] = this.calculateForCell(grid, x, y);
			}
		}
		return candidates;
	}

	/**
	 * 计算所有单元格的候选数（字典格式）
	 * @param {number[][]} grid - 数独网格
	 * @returns {Object} 候选数字典 { "x,y": [1,2,3], ... }
	 */
	calculateAllAsDict(grid) {
		const candidates = {};
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				if (grid[y][x] === 0) {
					const key = `${x},${y}`;
					candidates[key] = this.calculateForCell(grid, x, y);
				}
			}
		}
		return candidates;
	}
}

/**
 * 单例实例
 */
export const candidateCalculator = new CandidateCalculator();