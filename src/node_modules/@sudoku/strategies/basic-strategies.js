import { BaseStrategy } from './base-strategy.js';
import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';

/**
 * 策略1: Hidden Singles (隐藏单数)
 * 在行、列或宫中，某个数字只能出现在一个位置
 */
export class HiddenSingleStrategy extends BaseStrategy {
	constructor() {
		super('Hidden Singles', 1, 'Basic');
	}

	execute(grid, candidatesDict = null) {
		// 使用传入的候选数字典，如果没有则计算
		let candidates;
		if (candidatesDict) {
			// 将字典转换为矩阵格式
			candidates = [];
			for (let y = 0; y < SUDOKU_SIZE; y++) {
				candidates[y] = [];
				for (let x = 0; x < SUDOKU_SIZE; x++) {
					const key = `${x},${y}`;
					candidates[y][x] = candidatesDict[key] || [];
				}
			}
		} else {
			const clonedGrid = this.cloneGrid(grid);
			candidates = this.getAllCandidates(clonedGrid);
		}

		const eliminations = [];

		// 检查行
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			const positionsByNumber = Array.from({ length: SUDOKU_SIZE + 1 }, () => []);

			for (let x = 0; x < SUDOKU_SIZE; x++) {
				candidates[y][x].forEach(candidate => {
					positionsByNumber[candidate].push({ x, y });
				});
			}

			for (let value = 1; value <= SUDOKU_SIZE; value++) {
				if (positionsByNumber[value].length === 1) {
					const pos = positionsByNumber[value][0];
					// 删除该单元格中除了value之外的所有候选数
					const cellCandidates = candidates[pos.y][pos.x];
					const toRemove = cellCandidates.filter(c => c !== value);
					if (toRemove.length > 0) {
						eliminations.push({
							position: pos,
							removed: toRemove,
						});
					}
				}
			}
		}

		// 检查列
		for (let x = 0; x < SUDOKU_SIZE; x++) {
			const positionsByNumber = Array.from({ length: SUDOKU_SIZE + 1 }, () => []);

			for (let y = 0; y < SUDOKU_SIZE; y++) {
				candidates[y][x].forEach(candidate => {
					positionsByNumber[candidate].push({ x, y });
				});
			}

			for (let value = 1; value <= SUDOKU_SIZE; value++) {
				if (positionsByNumber[value].length === 1) {
					const pos = positionsByNumber[value][0];
					const cellCandidates = candidates[pos.y][pos.x];
					const toRemove = cellCandidates.filter(c => c !== value);
					if (toRemove.length > 0) {
						// 检查是否已存在
						const existing = eliminations.find(e => e.position.x === pos.x && e.position.y === pos.y);
						if (!existing) {
							eliminations.push({
								position: pos,
								removed: toRemove,
							});
						}
					}
				}
			}
		}

		// 检查宫
		for (let boxRow = 0; boxRow < BOX_SIZE; boxRow++) {
			for (let boxCol = 0; boxCol < BOX_SIZE; boxCol++) {
				const positionsByNumber = Array.from({ length: SUDOKU_SIZE + 1 }, () => []);

				for (let y = boxRow * BOX_SIZE; y < (boxRow + 1) * BOX_SIZE; y++) {
					for (let x = boxCol * BOX_SIZE; x < (boxCol + 1) * BOX_SIZE; x++) {
						candidates[y][x].forEach(candidate => {
							positionsByNumber[candidate].push({ x, y });
						});
					}
				}

				for (let value = 1; value <= SUDOKU_SIZE; value++) {
					if (positionsByNumber[value].length === 1) {
						const pos = positionsByNumber[value][0];
						const cellCandidates = candidates[pos.y][pos.x];
						const toRemove = cellCandidates.filter(c => c !== value);
						if (toRemove.length > 0) {
							const existing = eliminations.find(e => e.position.x === pos.x && e.position.y === pos.y);
							if (!existing) {
								eliminations.push({
									position: pos,
									removed: toRemove,
								});
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Hidden Singles',
				explanation: `找到 ${eliminations.length} 个隐藏单数，删除这些单元格中的其他候选数。`,
			};
		}

		return null;
	}
}

/**
 * 策略2: Naked Pairs (显式数对)
 * 两个单元格在同一行/列/宫中只有相同的两个候选数
 */
export class NakedPairsStrategy extends BaseStrategy {
	constructor() {
		super('Naked Pairs', 2, 'Basic');
	}

	execute(grid, candidatesDict = null) {
		// 使用传入的候选数字典，如果没有则计算
		let candidates;
		if (candidatesDict) {
			candidates = [];
			for (let y = 0; y < SUDOKU_SIZE; y++) {
				candidates[y] = [];
				for (let x = 0; x < SUDOKU_SIZE; x++) {
					const key = `${x},${y}`;
					candidates[y][x] = candidatesDict[key] || [];
				}
			}
		} else {
			const clonedGrid = this.cloneGrid(grid);
			candidates = this.getAllCandidates(clonedGrid);
		}

		const eliminations = [];

		// 检查行
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			for (let x1 = 0; x1 < SUDOKU_SIZE - 1; x1++) {
				if (candidates[y][x1].length !== 2) continue;

				for (let x2 = x1 + 1; x2 < SUDOKU_SIZE; x2++) {
					if (candidates[y][x2].length !== 2) continue;

					const pair1 = candidates[y][x1].sort().join(',');
					const pair2 = candidates[y][x2].sort().join(',');

					if (pair1 === pair2) {
						// 找到数对，删除其他单元格中的数对候选数
						const pairValues = candidates[y][x1];
						
						for (let x = 0; x < SUDOKU_SIZE; x++) {
							if (x !== x1 && x !== x2 && candidates[y][x].length > 0) {
								const toRemove = candidates[y][x].filter(c => pairValues.includes(c));
								if (toRemove.length > 0) {
									eliminations.push({
										position: { x, y },
										removed: toRemove,
									});
								}
							}
						}
					}
				}
			}
		}

		// 检查列
		for (let x = 0; x < SUDOKU_SIZE; x++) {
			for (let y1 = 0; y1 < SUDOKU_SIZE - 1; y1++) {
				if (candidates[y1][x].length !== 2) continue;

				for (let y2 = y1 + 1; y2 < SUDOKU_SIZE; y2++) {
					if (candidates[y2][x].length !== 2) continue;

					const pair1 = candidates[y1][x].sort().join(',');
					const pair2 = candidates[y2][x].sort().join(',');

					if (pair1 === pair2) {
						const pairValues = candidates[y1][x];
						for (let y = 0; y < SUDOKU_SIZE; y++) {
							if (y !== y1 && y !== y2 && candidates[y][x].length > 0) {
								const toRemove = candidates[y][x].filter(c => pairValues.includes(c));
								if (toRemove.length > 0) {
									eliminations.push({
										position: { x, y },
										removed: toRemove,
									});
								}
							}
						}
					}
				}
			}
		}

		// 检查宫
		for (let boxRow = 0; boxRow < BOX_SIZE; boxRow++) {
			for (let boxCol = 0; boxCol < BOX_SIZE; boxCol++) {
				const cells = [];
				for (let y = boxRow * BOX_SIZE; y < (boxRow + 1) * BOX_SIZE; y++) {
					for (let x = boxCol * BOX_SIZE; x < (boxCol + 1) * BOX_SIZE; x++) {
						if (candidates[y][x].length === 2) {
							cells.push({ x, y, candidates: candidates[y][x] });
						}
					}
				}

				for (let i = 0; i < cells.length - 1; i++) {
					for (let j = i + 1; j < cells.length; j++) {
						const pair1 = cells[i].candidates.sort().join(',');
						const pair2 = cells[j].candidates.sort().join(',');
						if (pair1 === pair2) {
							const pairValues = cells[i].candidates;
							for (let y = boxRow * BOX_SIZE; y < (boxRow + 1) * BOX_SIZE; y++) {
								for (let x = boxCol * BOX_SIZE; x < (boxCol + 1) * BOX_SIZE; x++) {
									if ((x !== cells[i].x || y !== cells[i].y) && 
									    (x !== cells[j].x || y !== cells[j].y) && 
									    candidates[y][x].length > 0) {
										const toRemove = candidates[y][x].filter(c => pairValues.includes(c));
										if (toRemove.length > 0) {
											eliminations.push({
												position: { x, y },
												removed: toRemove,
											});
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Naked Pairs',
				explanation: `找到数对，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}

/**
 * 策略3: Pointing Pairs (指向数对)
 * 当某个数字在宫中的候选位置都在同一行或同一列时，可以从该行/列的其他单元格中消除该数字
 */
export class PointingPairsStrategy extends BaseStrategy {
	constructor() {
		super('Pointing Pairs', 3, 'Basic');
	}

	execute(grid, candidatesDict = null) {
		// 使用传入的候选数字典，如果没有则计算
		let candidates;
		if (candidatesDict) {
			candidates = [];
			for (let y = 0; y < SUDOKU_SIZE; y++) {
				candidates[y] = [];
				for (let x = 0; x < SUDOKU_SIZE; x++) {
					const key = `${x},${y}`;
					candidates[y][x] = candidatesDict[key] || [];
				}
			}
		} else {
			const clonedGrid = this.cloneGrid(grid);
			candidates = this.getAllCandidates(clonedGrid);
		}

		const eliminations = [];

		// 检查每个宫
		for (let boxRow = 0; boxRow < BOX_SIZE; boxRow++) {
			for (let boxCol = 0; boxCol < BOX_SIZE; boxCol++) {
				for (let value = 1; value <= SUDOKU_SIZE; value++) {
					const positions = [];

					for (let y = boxRow * BOX_SIZE; y < (boxRow + 1) * BOX_SIZE; y++) {
						for (let x = boxCol * BOX_SIZE; x < (boxCol + 1) * BOX_SIZE; x++) {
							if (candidates[y][x].includes(value)) {
								positions.push({ x, y });
							}
						}
					}

					if (positions.length >= 2 && positions.length <= 3) {
						// 检查是否在同一行
						const rows = new Set(positions.map(p => p.y));
						if (rows.size === 1) {
							const row = positions[0].y;
							// 删除该行其他单元格中的该候选数
							for (let x = 0; x < SUDOKU_SIZE; x++) {
								const inBox = x >= boxCol * BOX_SIZE && x < (boxCol + 1) * BOX_SIZE;
								if (!inBox && candidates[row][x].includes(value)) {
									eliminations.push({
										position: { x, y: row },
										removed: [value],
									});
								}
							}
						}

						// 检查是否在同一列
						const cols = new Set(positions.map(p => p.x));
						if (cols.size === 1) {
							const col = positions[0].x;
							for (let y = 0; y < SUDOKU_SIZE; y++) {
								const inBox = y >= boxRow * BOX_SIZE && y < (boxRow + 1) * BOX_SIZE;
								if (!inBox && candidates[y][col].includes(value)) {
									eliminations.push({
										position: { x: col, y },
										removed: [value],
									});
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Pointing Pairs',
				explanation: `找到指向数对，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}

/**
 * 策略4: Box/Line Reduction (宫/线约简)
 * 当某个数字在行/列中的候选位置都在同一个宫中时，可以从该宫的其他单元格中消除该数字
 */
export class BoxLineReductionStrategy extends BaseStrategy {
	constructor() {
		super('Box/Line Reduction', 4, 'Basic');
	}

	execute(grid, candidatesDict = null) {
		// 使用传入的候选数字典，如果没有则计算
		let candidates;
		if (candidatesDict) {
			candidates = [];
			for (let y = 0; y < SUDOKU_SIZE; y++) {
				candidates[y] = [];
				for (let x = 0; x < SUDOKU_SIZE; x++) {
					const key = `${x},${y}`;
					candidates[y][x] = candidatesDict[key] || [];
				}
			}
		} else {
			const clonedGrid = this.cloneGrid(grid);
			candidates = this.getAllCandidates(clonedGrid);
		}

		const eliminations = [];

		// 检查行
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			for (let value = 1; value <= SUDOKU_SIZE; value++) {
				const positions = [];
				for (let x = 0; x < SUDOKU_SIZE; x++) {
					if (candidates[y][x].includes(value)) {
						positions.push({ x, y });
					}
				}

				if (positions.length >= 2 && positions.length <= 3) {
					const boxes = new Set(positions.map(p => Math.floor(p.x / BOX_SIZE)));
					if (boxes.size === 1) {
						const boxCol = positions[0].x;
						const boxStartCol = Math.floor(boxCol / BOX_SIZE) * BOX_SIZE;
						const boxStartRow = Math.floor(y / BOX_SIZE) * BOX_SIZE;

						// 删除该宫其他单元格中的该候选数
						for (let row = boxStartRow; row < boxStartRow + BOX_SIZE; row++) {
							for (let col = boxStartCol; col < boxStartCol + BOX_SIZE; col++) {
								if (row !== y && candidates[row][col].includes(value)) {
									eliminations.push({
										position: { x: col, y: row },
										removed: [value],
									});
								}
							}
						}
					}
				}
			}
		}

		// 检查列
		for (let x = 0; x < SUDOKU_SIZE; x++) {
			for (let value = 1; value <= SUDOKU_SIZE; value++) {
				const positions = [];
				for (let y = 0; y < SUDOKU_SIZE; y++) {
					if (candidates[y][x].includes(value)) {
						positions.push({ x, y });
					}
				}

				if (positions.length >= 2 && positions.length <= 3) {
					const boxes = new Set(positions.map(p => Math.floor(p.y / BOX_SIZE)));
					if (boxes.size === 1) {
						const boxRow = positions[0].y;
						const boxStartRow = Math.floor(boxRow / BOX_SIZE) * BOX_SIZE;
						const boxStartCol = Math.floor(x / BOX_SIZE) * BOX_SIZE;

						// 删除该宫其他单元格中的该候选数
						for (let row = boxStartRow; row < boxStartRow + BOX_SIZE; row++) {
							for (let col = boxStartCol; col < boxStartCol + BOX_SIZE; col++) {
								if (col !== x && candidates[row][col].includes(value)) {
									eliminations.push({
										position: { x: col, y: row },
										removed: [value],
									});
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Box/Line Reduction',
				explanation: `找到宫/线约简，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}

/**
 * 策略5: Naked Triples (显式三数组)
 * 三个单元格在同一行/列/宫中只有相同的三个候选数（或子集）
 */
export class NakedTriplesStrategy extends BaseStrategy {
	constructor() {
		super('Naked Triples', 5, 'Basic');
	}

	execute(grid, candidatesDict = null) {
		// 使用传入的候选数字典，如果没有则计算
		let candidates;
		if (candidatesDict) {
			candidates = [];
			for (let y = 0; y < SUDOKU_SIZE; y++) {
				candidates[y] = [];
				for (let x = 0; x < SUDOKU_SIZE; x++) {
					const key = `${x},${y}`;
					candidates[y][x] = candidatesDict[key] || [];
				}
			}
		} else {
			const clonedGrid = this.cloneGrid(grid);
			candidates = this.getAllCandidates(clonedGrid);
		}

		const eliminations = [];

		// 检查行
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			for (let x1 = 0; x1 < SUDOKU_SIZE - 2; x1++) {
				if (candidates[y][x1].length < 2 || candidates[y][x1].length > 3) continue;

				for (let x2 = x1 + 1; x2 < SUDOKU_SIZE - 1; x2++) {
					if (candidates[y][x2].length < 2 || candidates[y][x2].length > 3) continue;

					for (let x3 = x2 + 1; x3 < SUDOKU_SIZE; x3++) {
						if (candidates[y][x3].length < 2 || candidates[y][x3].length > 3) continue;

						const allCandidates = new Set([
							...candidates[y][x1],
							...candidates[y][x2],
							...candidates[y][x3],
						]);

						if (allCandidates.size === 3) {
							// 找到三数组，删除其他单元格中的三数组候选数
							const tripleValues = Array.from(allCandidates);
							for (let x = 0; x < SUDOKU_SIZE; x++) {
								if (x !== x1 && x !== x2 && x !== x3 && candidates[y][x].length > 0) {
									const toRemove = candidates[y][x].filter(c => allCandidates.has(c));
									if (toRemove.length > 0) {
										eliminations.push({
											position: { x, y },
											removed: toRemove,
										});
									}
								}
							}
						}
					}
				}
			}
		}

		// 检查列
		for (let x = 0; x < SUDOKU_SIZE; x++) {
			for (let y1 = 0; y1 < SUDOKU_SIZE - 2; y1++) {
				if (candidates[y1][x].length < 2 || candidates[y1][x].length > 3) continue;

				for (let y2 = y1 + 1; y2 < SUDOKU_SIZE - 1; y2++) {
					if (candidates[y2][x].length < 2 || candidates[y2][x].length > 3) continue;

					for (let y3 = y2 + 1; y3 < SUDOKU_SIZE; y3++) {
						if (candidates[y3][x].length < 2 || candidates[y3][x].length > 3) continue;

						const allCandidates = new Set([
							...candidates[y1][x],
							...candidates[y2][x],
							...candidates[y3][x],
						]);

						if (allCandidates.size === 3) {
							const tripleValues = Array.from(allCandidates);
							for (let y = 0; y < SUDOKU_SIZE; y++) {
								if (y !== y1 && y !== y2 && y !== y3 && candidates[y][x].length > 0) {
									const toRemove = candidates[y][x].filter(c => allCandidates.has(c));
									if (toRemove.length > 0) {
										eliminations.push({
											position: { x, y },
											removed: toRemove,
										});
									}
								}
							}
						}
					}
				}
			}
		}

		// 检查宫
		for (let boxRow = 0; boxRow < BOX_SIZE; boxRow++) {
			for (let boxCol = 0; boxCol < BOX_SIZE; boxCol++) {
				const cells = [];
				for (let y = boxRow * BOX_SIZE; y < (boxRow + 1) * BOX_SIZE; y++) {
					for (let x = boxCol * BOX_SIZE; x < (boxCol + 1) * BOX_SIZE; x++) {
						if (candidates[y][x].length >= 2 && candidates[y][x].length <= 3) {
							cells.push({ x, y, candidates: candidates[y][x] });
						}
					}
				}

				for (let i = 0; i < cells.length - 2; i++) {
					for (let j = i + 1; j < cells.length - 1; j++) {
						for (let k = j + 1; k < cells.length; k++) {
							const allCandidates = new Set([
								...cells[i].candidates,
								...cells[j].candidates,
								...cells[k].candidates,
							]);

							if (allCandidates.size === 3) {
								for (let y = boxRow * BOX_SIZE; y < (boxRow + 1) * BOX_SIZE; y++) {
									for (let x = boxCol * BOX_SIZE; x < (boxCol + 1) * BOX_SIZE; x++) {
										if ((x !== cells[i].x || y !== cells[i].y) && 
										    (x !== cells[j].x || y !== cells[j].y) && 
										    (x !== cells[k].x || y !== cells[k].y) && 
										    candidates[y][x].length > 0) {
											const toRemove = candidates[y][x].filter(c => allCandidates.has(c));
											if (toRemove.length > 0) {
												eliminations.push({
													position: { x, y },
													removed: toRemove,
												});
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Naked Triples',
				explanation: `找到三数组，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}
