import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';
import { candidateCalculator } from '../services/candidate-calculator.js';
import { candidateConverter } from '../services/candidate-converter.js';

/**
 * 策略基类 - 定义所有数独策略的统一接口
 * 
 * OOAD设计原则：
 * 1. 单一职责：每个策略类只负责一种求解方法
 * 2. 开闭原则：通过继承扩展新策略，无需修改现有代码
 * 3. 里氏替换：所有策略可互相替换使用
 * 4. 依赖倒置：依赖抽象接口而非具体实现
 * 5. 组合优于继承：使用候选数计算器服务，而不是重复实现
 */
export class BaseStrategy {
	constructor(name, id, category = 'Basic') {
		this.name = name;
		this.id = id;
		this.category = category;
		this.candidateCalculator = candidateCalculator;
		this.candidateConverter = candidateConverter;
	}

	/**
	 * 深拷贝网格，确保算法独立性
	 * 防止策略执行时修改原始数据影响其他策略
	 */
	cloneGrid(grid) {
		return grid.map(row => [...row]);
	}

	/**
	 * 获取单元格的候选数字
	 * 这是所有策略的基础方法
	 * 委托给候选数计算器，避免代码重复
	 */
	getCandidates(grid, x, y) {
		return this.candidateCalculator.calculateForCell(grid, x, y);
	}

	/**
	 * 获取所有单元格的候选数字矩阵
	 * 委托给候选数计算器
	 */
	getAllCandidates(grid) {
		return this.candidateCalculator.calculateAllAsMatrix(grid);
	}

	/**
	 * 将候选数字典转换为矩阵格式
	 * 委托给候选数转换器
	 */
	convertDictToMatrix(candidatesDict) {
		return this.candidateConverter.dictToMatrix(candidatesDict);
	}

	/**
	 * 验证策略结果的正确性
	 * 确保建议的值不违反数独规则
	 */
	validateResult(grid, position, value) {
		const { x, y } = position;

		// 检查单元格是否已填充
		if (grid[y][x] !== 0) return false;

		// 检查行
		for (let i = 0; i < SUDOKU_SIZE; i++) {
			if (i !== x && grid[y][i] === value) return false;
		}

		// 检查列
		for (let i = 0; i < SUDOKU_SIZE; i++) {
			if (i !== y && grid[i][x] === value) return false;
		}

		// 检查宫
		const startRow = Math.floor(y / BOX_SIZE) * BOX_SIZE;
		const startCol = Math.floor(x / BOX_SIZE) * BOX_SIZE;
		for (let row = startRow; row < startRow + BOX_SIZE; row++) {
			for (let col = startCol; col < startCol + BOX_SIZE; col++) {
				if (row !== y && col !== x && grid[row][col] === value) return false;
			}
		}

		return true;
	}

	/**
	 * 执行策略 - 子类必须实现
	 * @param {number[][]} grid - 数独网格（会被深拷贝，不会修改原数据）
	 * @param {Object} candidates - 当前候选数字典 { "x,y": [1,2,3], ... }
	 * @returns {Object|null} 策略结果或null
	 * {
	 *   type: 'solve' | 'eliminate',  // solve: 确定数字, eliminate: 删除候选数
	 *   position?: {x, y},  // solve时使用
	 *   value?: number,  // solve时使用
	 *   eliminations?: Array<{position: {x,y}, removed: number[]}>,  // eliminate时使用
	 *   strategy: string,
	 *   explanation: string,
	 *   candidates?: number[],
	 * }
	 */
	execute(grid, candidates = null) {
		throw new Error('Strategy.execute() must be implemented by subclass');
	}

	/**
	 * 获取策略描述
	 */
	getDescription() {
		return {
			id: this.id,
			name: this.name,
			category: this.category,
		};
	}
}
