import { BaseStrategy } from './base-strategy.js';
import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';

/**
 * 策略6: BUG (Bivalue Universal Grave)
 * 当所有未解决的单元格都只有两个候选数时，如果出现BUG模式，可以删除某些候选数
 */
export class BUGStrategy extends BaseStrategy {
	constructor() {
		super('BUG', 6, 'Tough');
	}

	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		// 检查是否所有未解决单元格都只有两个候选数
		let allBivalue = true;
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				if (grid[y][x] === 0 && candidates[y][x].length !== 2) {
					allBivalue = false;
					break;
				}
			}
			if (!allBivalue) break;
		}

		if (!allBivalue) return null;

		// 查找BUG模式：某个数字在行/列/宫中出现奇数次
		const eliminations = [];

		for (let value = 1; value <= SUDOKU_SIZE; value++) {
			// 检查行
			for (let y = 0; y < SUDOKU_SIZE; y++) {
				let count = 0;
				let bugCell = null;
				for (let x = 0; x < SUDOKU_SIZE; x++) {
					if (grid[y][x] === 0 && candidates[y][x].includes(value)) {
						count++;
						if (candidates[y][x].length === 2) {
							bugCell = { x, y };
						}
					}
				}
				// 如果出现奇数次且只有一个双值单元格包含该数字
				if (count % 2 === 1 && bugCell) {
					// 删除该单元格中的另一个候选数
					const otherCandidate = candidates[bugCell.y][bugCell.x].find(c => c !== value);
					if (otherCandidate) {
						eliminations.push({
							position: bugCell,
							removed: [otherCandidate],
						});
					}
				}
			}

			// 检查列
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				let count = 0;
				let bugCell = null;
				for (let y = 0; y < SUDOKU_SIZE; y++) {
					if (grid[y][x] === 0 && candidates[y][x].includes(value)) {
						count++;
						if (candidates[y][x].length === 2) {
							bugCell = { x, y };
						}
					}
				}
				if (count % 2 === 1 && bugCell) {
					const otherCandidate = candidates[bugCell.y][bugCell.x].find(c => c !== value);
					if (otherCandidate) {
						eliminations.push({
							position: bugCell,
							removed: [otherCandidate],
						});
					}
				}
			}

			// 检查宫
			for (let boxRow = 0; boxRow < BOX_SIZE; boxRow++) {
				for (let boxCol = 0; boxCol < BOX_SIZE; boxCol++) {
					let count = 0;
					let bugCell = null;
					for (let y = boxRow * BOX_SIZE; y < (boxRow + 1) * BOX_SIZE; y++) {
						for (let x = boxCol * BOX_SIZE; x < (boxCol + 1) * BOX_SIZE; x++) {
							if (grid[y][x] === 0 && candidates[y][x].includes(value)) {
								count++;
								if (candidates[y][x].length === 2) {
									bugCell = { x, y };
								}
							}
						}
					}
					if (count % 2 === 1 && bugCell) {
						const otherCandidate = candidates[bugCell.y][bugCell.x].find(c => c !== value);
						if (otherCandidate) {
							eliminations.push({
								position: bugCell,
								removed: [otherCandidate],
							});
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'BUG',
				explanation: `找到BUG模式，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}

/**
 * 策略7: X-Wing
 * 当某个数字在两行（或两列）中，都只出现在相同的两列（或两行）时，可以从这两列（或两行）的其他单元格中删除该数字
 */
export class XWingStrategy extends BaseStrategy {
	constructor() {
		super('X-Wing', 7, 'Tough');
	}

	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 检查行的X-Wing
		for (let value = 1; value <= SUDOKU_SIZE; value++) {
			for (let row1 = 0; row1 < SUDOKU_SIZE - 1; row1++) {
				const cols1 = [];
				for (let x = 0; x < SUDOKU_SIZE; x++) {
					if (grid[row1][x] === 0 && candidates[row1][x].includes(value)) {
						cols1.push(x);
					}
				}
				if (cols1.length !== 2) continue;

				for (let row2 = row1 + 1; row2 < SUDOKU_SIZE; row2++) {
					const cols2 = [];
					for (let x = 0; x < SUDOKU_SIZE; x++) {
						if (grid[row2][x] === 0 && candidates[row2][x].includes(value)) {
							cols2.push(x);
						}
					}
					if (cols2.length !== 2) continue;

					// 检查是否相同的两列
					if (cols1[0] === cols2[0] && cols1[1] === cols2[1]) {
						// 从这两列的其他行中删除该候选数
						for (let y = 0; y < SUDOKU_SIZE; y++) {
							if (y !== row1 && y !== row2) {
								if (candidates[y][cols1[0]].includes(value)) {
									eliminations.push({
										position: { x: cols1[0], y },
										removed: [value],
									});
								}
								if (candidates[y][cols1[1]].includes(value)) {
									eliminations.push({
										position: { x: cols1[1], y },
										removed: [value],
									});
								}
							}
						}
					}
				}
			}

			// 检查列的X-Wing
			for (let col1 = 0; col1 < SUDOKU_SIZE - 1; col1++) {
				const rows1 = [];
				for (let y = 0; y < SUDOKU_SIZE; y++) {
					if (grid[y][col1] === 0 && candidates[y][col1].includes(value)) {
						rows1.push(y);
					}
				}
				if (rows1.length !== 2) continue;

				for (let col2 = col1 + 1; col2 < SUDOKU_SIZE; col2++) {
					const rows2 = [];
					for (let y = 0; y < SUDOKU_SIZE; y++) {
						if (grid[y][col2] === 0 && candidates[y][col2].includes(value)) {
							rows2.push(y);
						}
					}
					if (rows2.length !== 2) continue;

					if (rows1[0] === rows2[0] && rows1[1] === rows2[1]) {
						// 从这两行的其他列中删除该候选数
						for (let x = 0; x < SUDOKU_SIZE; x++) {
							if (x !== col1 && x !== col2) {
								if (candidates[rows1[0]][x].includes(value)) {
									eliminations.push({
										position: { x, y: rows1[0] },
										removed: [value],
									});
								}
								if (candidates[rows1[1]][x].includes(value)) {
									eliminations.push({
										position: { x, y: rows1[1] },
										removed: [value],
									});
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'X-Wing',
				explanation: `找到X-Wing模式，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}

/**
 * 策略8: Unique Rectangles Type 1
 * 当四个单元格形成矩形，且都只有两个相同的候选数时，如果其中三个单元格在同一行/列/宫中，可以删除第四个单元格的候选数
 */
export class UniqueRectangles1Strategy extends BaseStrategy {
	constructor() {
		super('Unique Rectangles 1', 8, 'Tough');
	}

	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 查找形成矩形的四个单元格
		for (let r1 = 0; r1 < SUDOKU_SIZE - 1; r1++) {
			for (let c1 = 0; c1 < SUDOKU_SIZE - 1; c1++) {
				if (grid[r1][c1] !== 0) continue;

				for (let r2 = r1 + 1; r2 < SUDOKU_SIZE; r2++) {
					for (let c2 = c1 + 1; c2 < SUDOKU_SIZE; c2++) {
						if (grid[r2][c2] !== 0) continue;

						// 检查是否形成矩形：(r1,c1), (r1,c2), (r2,c1), (r2,c2)
						if (grid[r1][c2] === 0 && grid[r2][c1] === 0) {
							const cell1 = candidates[r1][c1];
							const cell2 = candidates[r1][c2];
							const cell3 = candidates[r2][c1];
							const cell4 = candidates[r2][c2];

							// 检查是否都是双值单元格且候选数相同
							if (cell1.length === 2 && cell2.length === 2 && 
							    cell3.length === 2 && cell4.length === 2) {
								const set1 = new Set(cell1);
								const set2 = new Set(cell2);
								const set3 = new Set(cell3);
								const set4 = new Set(cell4);

								// 检查是否所有单元格都有相同的两个候选数
								if (set1.size === 2 && this.setsEqual(set1, set2) && 
								    this.setsEqual(set2, set3) && this.setsEqual(set3, set4)) {
									// 检查是否在同一宫
									const box1 = Math.floor(r1 / BOX_SIZE) * BOX_SIZE + Math.floor(c1 / BOX_SIZE);
									const box2 = Math.floor(r1 / BOX_SIZE) * BOX_SIZE + Math.floor(c2 / BOX_SIZE);
									const box3 = Math.floor(r2 / BOX_SIZE) * BOX_SIZE + Math.floor(c1 / BOX_SIZE);
									const box4 = Math.floor(r2 / BOX_SIZE) * BOX_SIZE + Math.floor(c2 / BOX_SIZE);

									// 如果三个单元格在同一宫，删除第四个单元格的候选数
									if (box1 === box2 && box2 === box3 && box3 !== box4) {
										eliminations.push({
											position: { x: c2, y: r2 },
											removed: [...cell4],
										});
									} else if (box1 === box2 && box2 === box4 && box4 !== box3) {
										eliminations.push({
											position: { x: c1, y: r2 },
											removed: [...cell3],
										});
									} else if (box1 === box3 && box3 === box4 && box4 !== box2) {
										eliminations.push({
											position: { x: c2, y: r1 },
											removed: [...cell2],
										});
									} else if (box2 === box3 && box3 === box4 && box4 !== box1) {
										eliminations.push({
											position: { x: c1, y: r1 },
											removed: [...cell1],
										});
									}
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Unique Rectangles 1',
				explanation: `找到唯一矩形类型1，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}

	setsEqual(set1, set2) {
		if (set1.size !== set2.size) return false;
		for (const item of set1) {
			if (!set2.has(item)) return false;
		}
		return true;
	}
}

/**
 * 策略9: Chute Remote Pairs
 * 当两个单元格形成远程数对时，可以删除它们之间的候选数
 */
export class ChuteRemotePairsStrategy extends BaseStrategy {
	constructor() {
		super('Chute Remote Pairs', 9, 'Tough');
	}

	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 查找远程数对：两个数对通过链连接
		// 简化实现：查找在同一行/列/宫中的数对
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			const pairs = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				if (grid[y][x] === 0 && candidates[y][x].length === 2) {
					pairs.push({ x, y, candidates: candidates[y][x] });
				}
			}

			// 查找相同的数对
			for (let i = 0; i < pairs.length - 1; i++) {
				for (let j = i + 1; j < pairs.length; j++) {
					const set1 = new Set(pairs[i].candidates);
					const set2 = new Set(pairs[j].candidates);
					
					if (set1.size === 2 && this.setsEqual(set1, set2)) {
						// 找到数对，检查它们之间是否有其他单元格
						const pairValues = Array.from(set1);
						const x1 = pairs[i].x;
						const x2 = pairs[j].x;
						
						// 如果两个数对之间有其他单元格，可以删除这些单元格中的数对候选数
						const minX = Math.min(x1, x2);
						const maxX = Math.max(x1, x2);
						
						for (let x = minX + 1; x < maxX; x++) {
							if (grid[y][x] === 0 && candidates[y][x].length > 0) {
								const toRemove = candidates[y][x].filter(c => pairValues.includes(c));
								if (toRemove.length > 0) {
									eliminations.push({
										position: { x, y },
										removed: toRemove,
									});
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Chute Remote Pairs',
				explanation: `找到远程数对，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}

	setsEqual(set1, set2) {
		if (set1.size !== set2.size) return false;
		for (const item of set1) {
			if (!set2.has(item)) return false;
		}
		return true;
	}
}

/**
 * 策略10: W-Wing
 * 当两个单元格通过一个强链接连接，且它们有相同的两个候选数时，可以删除某些候选数
 */
export class WWingStrategy extends BaseStrategy {
	constructor() {
	  super('W-Wing', 10, 'Tough');
	  // 更保守：减少误判（宁可少删）
	  this.DISALLOW_SAME_END_ATTACHMENT = true;
	  // 找到第一步就返回（更像人类解题）
	  this.RETURN_FIRST_FOUND = true;
	}
  
	execute(grid, candidatesDict = null) {
	  if (!candidatesDict) return null;
  
	  const cand = this.buildCandidates(grid, candidatesDict);
	  const units = this.getAllUnits();
	  const bivalueCells = this.getBivalueCells(grid, cand);
  
	  // 去重用
	  const elimSet = new Set();
	  const eliminations = [];
  
	  // 遍历所有双值端点对 P/Q
	  for (let i = 0; i < bivalueCells.length; i++) {
		const P = bivalueCells[i];
		for (let j = i + 1; j < bivalueCells.length; j++) {
		  const Q = bivalueCells[j];
  
		  // 同一对 {a,b}
		  if (P.a !== Q.a || P.b !== Q.b) continue;
  
		  // 互不可见
		  if (this.sees(P, Q)) continue;
  
		  const a = P.a, b = P.b;
  
		  // linkDigit 可为 a 或 b
		  for (const linkDigit of [a, b]) {
			const otherDigit = (linkDigit === a) ? b : a;
  
			// 在所有单位中找 linkDigit 的共轭对（强链）
			for (const unit of units) {
			  const ends = this.findConjugatePairInUnit(grid, cand, unit, linkDigit);
			  if (!ends) continue;
  
			  const L1 = ends[0];
			  const L2 = ends[1];
  
			  // 强链端点不能是 P/Q（更稳妥，避免混型导致误删）
			  if (this.sameCell(L1, P) || this.sameCell(L2, P) || this.sameCell(L1, Q) || this.sameCell(L2, Q)) {
				continue;
			  }
  
			  // 连接关系必须“交叉”
			  const p1 = this.sees(P, L1);
			  const p2 = this.sees(P, L2);
			  const q1 = this.sees(Q, L1);
			  const q2 = this.sees(Q, L2);
  
			  const crossOk = (p1 && q2) || (p2 && q1);
			  if (!crossOk) continue;
  
			  // 可选：禁止 P/Q 都连到强链同一端（更保守，减少伪 W-Wing）
			  if (this.DISALLOW_SAME_END_ATTACHMENT) {
				// 如果 P 和 Q 同时都能看到 L1 或同时都能看到 L2，则跳过
				if ((p1 && q1) || (p2 && q2)) continue;
			  }
  
			  // 确定“靠近 P 的强链端点”和“靠近 Q 的强链端点”
			  // 用于两分支验证
			  const LnearP = (p1 && q2) ? L1 : L2;
			  const LnearQ = (p1 && q2) ? L2 : L1;
  
			  // 轻量逻辑验证，防止候选集不一致/误判结构
			  if (!this.validateWWing(grid, cand, P, Q, LnearP, LnearQ, linkDigit, otherDigit)) {
				continue;
			  }
  
			  // 执行删除：删 peers(P) ∩ peers(Q) 中的 otherDigit
			  const commonPeers = this.intersectionPeers(P, Q);
			  for (const cell of commonPeers) {
				const x = cell.x, y = cell.y;
				if (grid[y][x] !== 0) continue;
  
				// 不能删到 P/Q 自己
				if ((x === P.x && y === P.y) || (x === Q.x && y === Q.y)) continue;
  
				if (!cand[y][x].includes(otherDigit)) continue;
  
				const key = `${x},${y},${otherDigit}`;
				if (elimSet.has(key)) continue;
				elimSet.add(key);
  
				eliminations.push({
				  position: { x, y },
				  removed: [otherDigit],
				  // 你若要 UI 高亮可加：meta: { P,Q, linkDigit, L1,L2 }
				});
			  }
  
			  if (eliminations.length > 0 && this.RETURN_FIRST_FOUND) {
				return {
				  type: 'eliminate',
				  eliminations,
				  strategy: 'W-Wing',
				  explanation: `W-Wing：端点(${P.x},${P.y})与(${Q.x},${Q.y})为{${a},${b}}，通过 ${linkDigit} 的共轭对形成强链，删除共同可见格中的 ${otherDigit}。`,
				};
			  }
			}
		  }
		}
	  }
  
	  if (eliminations.length > 0) {
		return {
		  type: 'eliminate',
		  eliminations,
		  strategy: 'W-Wing',
		  explanation: `W-Wing：通过共轭强链连接两端双值格，删除共同可见格中的另一候选数，共 ${eliminations.length} 处。`,
		};
	  }
  
	  return null;
	}
  
	// -----------------------------
	// 候选 & 结构工具
	// -----------------------------
  
	buildCandidates(grid, candidatesDict) {
	  const candidates = [];
	  for (let y = 0; y < SUDOKU_SIZE; y++) {
		candidates[y] = [];
		for (let x = 0; x < SUDOKU_SIZE; x++) {
		  const key = `${x},${y}`;
		  const arr = candidatesDict[key] || [];
		  // 防止重复/非法
		  const cleaned = Array.from(new Set(arr)).filter(v => Number.isInteger(v) && v >= 1 && v <= 9);
		  candidates[y][x] = cleaned;
		}
	  }
	  return candidates;
	}
  
	getBivalueCells(grid, cand) {
	  const out = [];
	  for (let y = 0; y < SUDOKU_SIZE; y++) {
		for (let x = 0; x < SUDOKU_SIZE; x++) {
		  if (grid[y][x] !== 0) continue;
		  const arr = cand[y][x];
		  if (arr.length !== 2) continue;
		  if (arr[0] === arr[1]) continue;
		  const pair = arr.slice().sort((m, n) => m - n);
		  out.push({ x, y, a: pair[0], b: pair[1] });
		}
	  }
	  return out;
	}
  
	// 在一个单位（9格）内找 digit 的共轭对：digit 只出现两次
	findConjugatePairInUnit(grid, cand, unit, digit) {
	  const pos = [];
	  for (const c of unit) {
		const x = c.x, y = c.y;
		if (grid[y][x] !== 0) continue;
		if (cand[y][x].includes(digit)) pos.push({ x, y });
		if (pos.length > 2) return null;
	  }
	  return pos.length === 2 ? pos : null;
	}
  
	// 互相可见（同行/同列/同宫）
	sees(c1, c2) {
	  if (c1.x === c2.x) return true;
	  if (c1.y === c2.y) return true;
	  return (
		Math.floor(c1.x / BOX_SIZE) === Math.floor(c2.x / BOX_SIZE) &&
		Math.floor(c1.y / BOX_SIZE) === Math.floor(c2.y / BOX_SIZE)
	  );
	}
  
	sameCell(c1, c2) {
	  return c1.x === c2.x && c1.y === c2.y;
	}
  
	// peers(P) ∩ peers(Q)
	intersectionPeers(P, Q) {
	  const peersP = this.getPeers(P.x, P.y);
	  const peersQ = this.getPeers(Q.x, Q.y);
	  const setQ = new Set(peersQ.map(p => `${p.x},${p.y}`));
	  return peersP.filter(p => setQ.has(`${p.x},${p.y}`));
	}
  
	getPeers(x, y) {
	  const peers = [];
	  const seen = new Set();
	  const add = (px, py) => {
		if (px === x && py === y) return;
		const k = `${px},${py}`;
		if (seen.has(k)) return;
		seen.add(k);
		peers.push({ x: px, y: py });
	  };
  
	  // row
	  for (let cx = 0; cx < SUDOKU_SIZE; cx++) add(cx, y);
	  // col
	  for (let cy = 0; cy < SUDOKU_SIZE; cy++) add(x, cy);
	  // box
	  const bx = Math.floor(x / BOX_SIZE) * BOX_SIZE;
	  const by = Math.floor(y / BOX_SIZE) * BOX_SIZE;
	  for (let dy = 0; dy < BOX_SIZE; dy++) {
		for (let dx = 0; dx < BOX_SIZE; dx++) add(bx + dx, by + dy);
	  }
  
	  return peers;
	}
  
	getAllUnits() {
	  const units = [];
  
	  // rows
	  for (let y = 0; y < SUDOKU_SIZE; y++) {
		const row = [];
		for (let x = 0; x < SUDOKU_SIZE; x++) row.push({ x, y });
		units.push(row);
	  }
  
	  // cols
	  for (let x = 0; x < SUDOKU_SIZE; x++) {
		const col = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) col.push({ x, y });
		units.push(col);
	  }
  
	  // boxes
	  for (let by = 0; by < SUDOKU_SIZE; by += BOX_SIZE) {
		for (let bx = 0; bx < SUDOKU_SIZE; bx += BOX_SIZE) {
		  const box = [];
		  for (let dy = 0; dy < BOX_SIZE; dy++) {
			for (let dx = 0; dx < BOX_SIZE; dx++) {
			  box.push({ x: bx + dx, y: by + dy });
			}
		  }
		  units.push(box);
		}
	  }
  
	  return units;
	}
  
	// -----------------------------
	// 防误判：两分支轻量验证
	// -----------------------------
	validateWWing(grid, cand, P, Q, LnearP, LnearQ, linkDigit, otherDigit) {
	  // 基本候选存在性（候选集不一致时直接拒绝）
	  if (grid[P.y][P.x] !== 0 || grid[Q.y][Q.x] !== 0) return false;
	  const pCand = cand[P.y][P.x];
	  const qCand = cand[Q.y][Q.x];
	  if (!(pCand.includes(linkDigit) && pCand.includes(otherDigit))) return false;
	  if (!(qCand.includes(linkDigit) && qCand.includes(otherDigit))) return false;
  
	  // 强链端点候选里必须有 linkDigit
	  if (grid[LnearP.y][LnearP.x] !== 0 || grid[LnearQ.y][LnearQ.x] !== 0) return false;
	  if (!cand[LnearP.y][LnearP.x].includes(linkDigit)) return false;
	  if (!cand[LnearQ.y][LnearQ.x].includes(linkDigit)) return false;
  
	  // 结构上必须可见：P sees LnearP, Q sees LnearQ
	  if (!this.sees(P, LnearP)) return false;
	  if (!this.sees(Q, LnearQ)) return false;
  
	  // 分支1：假设 P=otherDigit，则 P!=linkDigit -> LnearP 不能为 linkDigit -> 强链推出 LnearQ=linkDigit -> Q!=linkDigit -> Q=otherDigit
	  // 这里我们只做“候选存在性”的一致检查（轻量但有效）
	  if (!pCand.includes(otherDigit)) return false;
	  if (!qCand.includes(otherDigit)) return false;
  
	  // 分支2：假设 P=linkDigit ->（按 W-Wing 逻辑）Q=linkDigit
	  if (!pCand.includes(linkDigit)) return false;
	  if (!qCand.includes(linkDigit)) return false;
  
	  return true;
	}
  }
  
  

/**
 * 策略11: Y-Wing
 * 当三个单元格形成Y形连接，且满足特定条件时，可以删除某些候选数
 */
export class YWingStrategy extends BaseStrategy {
	constructor() {
		super('Y-Wing', 11, 'Tough');
	}

	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		const candidates = Array.from({ length: SUDOKU_SIZE }, (_, y) =>
			Array.from({ length: SUDOKU_SIZE }, (_, x) => {
				const key = `${x},${y}`;
				return candidatesDict[key] || [];
			})
		);

		const inSameBox = (x1, y1, x2, y2) =>
			Math.floor(x1 / BOX_SIZE) === Math.floor(x2 / BOX_SIZE) &&
			Math.floor(y1 / BOX_SIZE) === Math.floor(y2 / BOX_SIZE);

		const sees = (x1, y1, x2, y2) =>
			x1 === x2 || y1 === y2 || inSameBox(x1, y1, x2, y2);

		// 用 Map 去重：key = "x,y,val"
		const elimMap = new Map();

		for (let y1 = 0; y1 < SUDOKU_SIZE; y1++) {
			for (let x1 = 0; x1 < SUDOKU_SIZE; x1++) {
				if (grid[y1][x1] !== 0) continue;
				if (candidates[y1][x1].length !== 2) continue;

				const [a, b] = candidates[y1][x1];
				if (a === b) continue;

				// 找 pincer1: {a,c} 且能看见 hinge
				for (let y2 = 0; y2 < SUDOKU_SIZE; y2++) {
					for (let x2 = 0; x2 < SUDOKU_SIZE; x2++) {
						if (x2 === x1 && y2 === y1) continue;
						if (grid[y2][x2] !== 0) continue;
						if (candidates[y2][x2].length !== 2) continue;
						if (!sees(x1, y1, x2, y2)) continue; // 必须能看见 hinge

						const cand2 = candidates[y2][x2];
						if (!cand2.includes(a)) continue;

						const c = cand2[0] === a ? cand2[1] : cand2[0];
						if (c == null) continue;
						// 三个数必须互异
						if (c === a || c === b) continue;

						// 找 pincer2: {b,c} 且能看见 hinge
						for (let y3 = 0; y3 < SUDOKU_SIZE; y3++) {
							for (let x3 = 0; x3 < SUDOKU_SIZE; x3++) {
								if ((x3 === x1 && y3 === y1) || (x3 === x2 && y3 === y2)) continue;
								if (grid[y3][x3] !== 0) continue;
								if (candidates[y3][x3].length !== 2) continue;
								if (!sees(x1, y1, x3, y3)) continue; // 必须能看见 hinge

								const cand3 = candidates[y3][x3];
								if (!(cand3.includes(b) && cand3.includes(c))) continue;

								// 现在 (x1,y1)=hinge {a,b}, (x2,y2)= {a,c}, (x3,y3)= {b,c}
								// 删 c：所有同时能看见两个 pincers 的格子（交集），但排除 hinge 和 pincers 自身
								for (let y = 0; y < SUDOKU_SIZE; y++) {
									for (let x = 0; x < SUDOKU_SIZE; x++) {
										if (grid[y][x] !== 0) continue;

										// 排除 hinge 与两翼本身
										if ((x === x1 && y === y1) || (x === x2 && y === y2) || (x === x3 && y === y3)) {
											continue;
										}

										// 必须同时看见两个 pincers
										if (!sees(x, y, x2, y2) || !sees(x, y, x3, y3)) continue;

										// 候选必须包含 c，且删除后不能变空（至少还剩一个）
										const cellCands = candidates[y][x];
										if (!cellCands || cellCands.length <= 1) continue;
										if (!cellCands.includes(c)) continue;

										const k = `${x},${y},${c}`;
										if (!elimMap.has(k)) {
											elimMap.set(k, { position: { x, y }, removed: [c] });
										}
									}
								}
							}
						}
					}
				}
			}
		}

		const eliminations = Array.from(elimMap.values());

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Y-Wing',
				explanation: `找到Y-Wing模式，删除了 ${eliminations.length} 个候选数。`,
			};
		}

		return null;
	}
}


/**
 * 策略12: Rectangle Elimination
 * 矩形消除策略
 */
export class RectangleEliminationStrategy extends BaseStrategy {
	constructor() {
		super('Rectangle Elimination', 12, 'Tough');
	}

	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 使用Unique Rectangles 2+的逻辑
		const uniqueRects2Plus = new UniqueRectangles2PlusStrategy();
		return uniqueRects2Plus.execute(grid, candidatesDict);
	}
}

/**
 * 策略13: Simple Colouring
 * 简单着色策略，通过给候选数着色来找到强链接和弱链接
 */
export class SimpleColouringStrategy extends BaseStrategy {
	constructor() {
		super('Simple Colouring', 13, 'Tough');
	}

	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 简化实现：使用X-Cycles的逻辑
		const xCycles = new XCyclesStrategy();
		return xCycles.execute(grid, candidatesDict);
	}
}

/**
 * 策略14: Quads Naked+Hidden
 * 四数组（显式和隐藏）
 */
export class QuadsStrategy extends BaseStrategy {
	constructor() {
		super('Quads Naked+Hidden', 14, 'Tough');
	}

	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 检查显式四数组（行）
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			const quadCells = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				if (grid[y][x] === 0 && candidates[y][x].length >= 2 && candidates[y][x].length <= 4) {
					quadCells.push({ x, y, candidates: candidates[y][x] });
				}
			}

			// 查找四个单元格，它们的候选数并集正好是4个数字
			for (let i = 0; i < quadCells.length - 3; i++) {
				for (let j = i + 1; j < quadCells.length - 2; j++) {
					for (let k = j + 1; k < quadCells.length - 1; k++) {
						for (let l = k + 1; l < quadCells.length; l++) {
							const allCandidates = new Set([
								...quadCells[i].candidates,
								...quadCells[j].candidates,
								...quadCells[k].candidates,
								...quadCells[l].candidates,
							]);

							if (allCandidates.size === 4) {
								const quadValues = Array.from(allCandidates);
								// 删除其他单元格中的四数组候选数
								for (let x = 0; x < SUDOKU_SIZE; x++) {
									if (x !== quadCells[i].x && x !== quadCells[j].x && 
									    x !== quadCells[k].x && x !== quadCells[l].x && 
									    candidates[y][x].length > 0) {
										const toRemove = candidates[y][x].filter(c => allCandidates.has(c));
										if (toRemove.length > 0) {
											eliminations.push({
												position: { x, y },
												removed: toRemove,
											});
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Quads Naked+Hidden',
				explanation: `找到四数组，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}

/**
 * 策略15: Swordfish
 * 剑鱼策略，X-Wing的扩展（三行三列）
 */
export class SwordfishStrategy extends BaseStrategy {
	constructor() {
		super('Swordfish', 15, 'Tough');
	}

	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 检查行的Swordfish
		for (let value = 1; value <= SUDOKU_SIZE; value++) {
			for (let row1 = 0; row1 < SUDOKU_SIZE - 2; row1++) {
				const cols1 = [];
				for (let x = 0; x < SUDOKU_SIZE; x++) {
					if (grid[row1][x] === 0 && candidates[row1][x].includes(value)) {
						cols1.push(x);
					}
				}
				if (cols1.length < 2 || cols1.length > 3) continue;

				for (let row2 = row1 + 1; row2 < SUDOKU_SIZE - 1; row2++) {
					const cols2 = [];
					for (let x = 0; x < SUDOKU_SIZE; x++) {
						if (grid[row2][x] === 0 && candidates[row2][x].includes(value)) {
							cols2.push(x);
						}
					}
					if (cols2.length < 2 || cols2.length > 3) continue;

					for (let row3 = row2 + 1; row3 < SUDOKU_SIZE; row3++) {
						const cols3 = [];
						for (let x = 0; x < SUDOKU_SIZE; x++) {
							if (grid[row3][x] === 0 && candidates[row3][x].includes(value)) {
								cols3.push(x);
							}
						}
						if (cols3.length < 2 || cols3.length > 3) continue;

						// 检查三行的列集合是否有交集且正好是2-3列
						const allCols = new Set([...cols1, ...cols2, ...cols3]);
						if (allCols.size >= 2 && allCols.size <= 3) {
							// 检查每列是否至少在两行中出现
							for (const col of allCols) {
								let count = 0;
								if (cols1.includes(col)) count++;
								if (cols2.includes(col)) count++;
								if (cols3.includes(col)) count++;
								if (count >= 2) {
									// 从该列的其他行中删除该候选数
									for (let y = 0; y < SUDOKU_SIZE; y++) {
										if (y !== row1 && y !== row2 && y !== row3) {
											if (candidates[y][col].includes(value)) {
												eliminations.push({
													position: { x: col, y },
													removed: [value],
												});
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Swordfish',
				explanation: `找到Swordfish模式，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}

/**
 * 策略16: XYZ Wing
 * XYZ Wing策略，三个单元格形成XYZ形
 */
export class XYZWingStrategy extends BaseStrategy {
	constructor() {
		super('XYZ Wing', 16, 'Tough');
	}

	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 查找XYZ Wing：一个三值单元格(xyz)和两个双值单元格(xz, yz)
		for (let y1 = 0; y1 < SUDOKU_SIZE; y1++) {
			for (let x1 = 0; x1 < SUDOKU_SIZE; x1++) {
				if (grid[y1][x1] !== 0 || candidates[y1][x1].length !== 3) continue;
				const [x, y, z] = candidates[y1][x1];

				// 查找包含xz的双值单元格
				for (let y2 = 0; y2 < SUDOKU_SIZE; y2++) {
					for (let x2 = 0; x2 < SUDOKU_SIZE; x2++) {
						if ((y1 === y2 && x1 === x2) || grid[y2][x2] !== 0) continue;
						if (candidates[y2][x2].length !== 2) continue;
						if (!candidates[y2][x2].includes(x) || !candidates[y2][x2].includes(z)) continue;

						// 查找包含yz的双值单元格
						for (let y3 = 0; y3 < SUDOKU_SIZE; y3++) {
							for (let x3 = 0; x3 < SUDOKU_SIZE; x3++) {
								if ((y1 === y3 && x1 === x3) || (y2 === y3 && x2 === x3)) continue;
								if (grid[y3][x3] !== 0) continue;
								if (candidates[y3][x3].length !== 2) continue;
								if (!candidates[y3][x3].includes(y) || !candidates[y3][x3].includes(z)) continue;

								// 检查cell2和cell3是否都与cell1相关
								const rel12 = (y1 === y2 || x1 === x2 || 
									(Math.floor(y1 / BOX_SIZE) === Math.floor(y2 / BOX_SIZE) && 
									 Math.floor(x1 / BOX_SIZE) === Math.floor(x2 / BOX_SIZE)));
								const rel13 = (y1 === y3 || x1 === x3 || 
									(Math.floor(y1 / BOX_SIZE) === Math.floor(y3 / BOX_SIZE) && 
									 Math.floor(x1 / BOX_SIZE) === Math.floor(x3 / BOX_SIZE)));

								if (rel12 && rel13) {
									// 查找与cell2和cell3都相关的单元格，删除z
									for (let y = 0; y < SUDOKU_SIZE; y++) {
										for (let x = 0; x < SUDOKU_SIZE; x++) {
											if (grid[y][x] !== 0) continue;
											const rel2 = (y === y2 || x === x2 || 
												(Math.floor(y / BOX_SIZE) === Math.floor(y2 / BOX_SIZE) && 
												 Math.floor(x / BOX_SIZE) === Math.floor(x2 / BOX_SIZE)));
											const rel3 = (y === y3 || x === x3 || 
												(Math.floor(y / BOX_SIZE) === Math.floor(y3 / BOX_SIZE) && 
												 Math.floor(x / BOX_SIZE) === Math.floor(x3 / BOX_SIZE)));

											if (rel2 && rel3 && candidates[y][x].includes(z)) {
												eliminations.push({
													position: { x, y },
													removed: [z],
												});
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'XYZ Wing',
				explanation: `找到XYZ Wing模式，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}

/**
 * 策略17-41: 高级策略（Diabolical, Extreme, Trial and Error）
 * 这些策略非常复杂，需要图算法、链式推理等
 * 为了保持框架完整性，我们提供占位实现
 * 后续可以根据需要逐步完善这些策略
 */

// 策略17-26: Diabolical Strategies
export class XCyclesStrategy extends BaseStrategy {
	constructor() { super('X-Cycles', 17, 'Diabolical'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 查找X-Cycles：某个数字的强链接形成循环
		for (let value = 1; value <= SUDOKU_SIZE; value++) {
			// 构建强链接图
			const strongLinks = this.buildStrongLinks(grid, candidates, value);
			
			// 查找循环
			const cycles = this.findCycles(strongLinks, 6);
			
			for (const cycle of cycles) {
				// 如果循环长度为偶数，可以删除某些候选数
				if (cycle.length % 2 === 0 && cycle.length >= 4) {
					// 查找与循环中所有单元格都相关的单元格
					for (let y = 0; y < SUDOKU_SIZE; y++) {
						for (let x = 0; x < SUDOKU_SIZE; x++) {
							if (grid[y][x] !== 0) continue;
							if (!candidates[y][x].includes(value)) continue;
							
							// 检查是否在循环中
							const inCycle = cycle.some(c => c.x === x && c.y === y);
							if (inCycle) continue;
							
							// 检查是否与循环中的所有单元格都相关
							let relatedToAll = true;
							for (const cell of cycle) {
								const related = (y === cell.y || x === cell.x || 
									(Math.floor(y / BOX_SIZE) === Math.floor(cell.y / BOX_SIZE) && 
									 Math.floor(x / BOX_SIZE) === Math.floor(cell.x / BOX_SIZE)));
								if (!related) {
									relatedToAll = false;
									break;
								}
							}
							
							if (relatedToAll) {
								eliminations.push({
									position: { x, y },
									removed: [value],
								});
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'X-Cycles',
				explanation: `找到X-Cycles，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}

	buildStrongLinks(grid, candidates, value) {
		const links = [];
		
		// 检查行中的强链接（某个数字只出现在两个位置）
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			const positions = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				if (grid[y][x] === 0 && candidates[y][x].includes(value)) {
					positions.push({ x, y });
				}
			}
			if (positions.length === 2) {
				links.push({ from: positions[0], to: positions[1] });
			}
		}
		
		// 检查列中的强链接
		for (let x = 0; x < SUDOKU_SIZE; x++) {
			const positions = [];
			for (let y = 0; y < SUDOKU_SIZE; y++) {
				if (grid[y][x] === 0 && candidates[y][x].includes(value)) {
					positions.push({ x, y });
				}
			}
			if (positions.length === 2) {
				links.push({ from: positions[0], to: positions[1] });
			}
		}
		
		// 检查宫中的强链接
		for (let boxRow = 0; boxRow < BOX_SIZE; boxRow++) {
			for (let boxCol = 0; boxCol < BOX_SIZE; boxCol++) {
				const positions = [];
				for (let y = boxRow * BOX_SIZE; y < (boxRow + 1) * BOX_SIZE; y++) {
					for (let x = boxCol * BOX_SIZE; x < (boxCol + 1) * BOX_SIZE; x++) {
						if (grid[y][x] === 0 && candidates[y][x].includes(value)) {
							positions.push({ x, y });
						}
					}
				}
				if (positions.length === 2) {
					links.push({ from: positions[0], to: positions[1] });
				}
			}
		}
		
		return links;
	}

	findCycles(links, maxLength) {
		const cycles = [];
		const graph = new Map();
		
		// 构建图
		for (const link of links) {
			const key1 = `${link.from.x},${link.from.y}`;
			const key2 = `${link.to.x},${link.to.y}`;
			
			if (!graph.has(key1)) graph.set(key1, []);
			if (!graph.has(key2)) graph.set(key2, []);
			
			graph.get(key1).push(link.to);
			graph.get(key2).push(link.from);
		}
		
		// 查找循环
		for (const [startKey, startPos] of graph) {
			const visited = new Set();
			const path = [startPos];
			
			this.dfsCycle(graph, startPos, startPos, visited, path, cycles, maxLength);
		}
		
		return cycles;
	}

	dfsCycle(graph, start, current, visited, path, cycles, maxLength) {
		if (path.length > maxLength) return;
		if (path.length >= 4 && path.length % 2 === 0) {
			const currentKey = `${current.x},${current.y}`;
			const startKey = `${start.x},${start.y}`;
			
			// 检查是否形成循环
			if (currentKey === startKey && path.length > 2) {
				cycles.push([...path]);
				return;
			}
		}
		
		const currentKey = `${current.x},${current.y}`;
		if (visited.has(currentKey)) return;
		
		visited.add(currentKey);
		const neighbors = graph.get(currentKey) || [];
		
		for (const neighbor of neighbors) {
			if (path.length === 1 || neighbor.x !== path[path.length - 2].x || neighbor.y !== path[path.length - 2].y) {
				path.push(neighbor);
				this.dfsCycle(graph, start, neighbor, visited, path, cycles, maxLength);
				path.pop();
			}
		}
		
		visited.delete(currentKey);
	}
}

export class XYChainStrategy extends BaseStrategy {
	constructor() { super('XY-Chain', 18, 'Diabolical'); }
  
	execute(grid, candidatesDict = null) {
	  if (!candidatesDict) return null;
  
	  // candidates[y][x] = [..]
	  const candidates = Array.from({ length: SUDOKU_SIZE }, (_, y) =>
		Array.from({ length: SUDOKU_SIZE }, (_, x) => candidatesDict[`${x},${y}`] || [])
	  );
  
	  const eliminations = [];
	  const elimSeen = new Set(); // dedupe: `${x},${y},${d}`
  
	  // 只从 bivalue 格出发
	  for (let startY = 0; startY < SUDOKU_SIZE; startY++) {
		for (let startX = 0; startX < SUDOKU_SIZE; startX++) {
		  if (grid[startY][startX] !== 0) continue;
		  const startCands = candidates[startY][startX];
		  if (startCands.length !== 2) continue;
  
		  const [xDigit, yDigit] = startCands;
  
		  // XY-Chain 的端点 digit：从 start 的某个候选 X 出发，沿链最终回到 X
		  // 我们分别尝试以 xDigit 作为端点digit（start用xDigit“被迫/假设”为真），和以 yDigit 作为端点digit
		  const chain1 = this.findXYChainDFS(grid, candidates, { x: startX, y: startY }, xDigit, yDigit, 4);
		  const chain2 = this.findXYChainDFS(grid, candidates, { x: startX, y: startY }, yDigit, xDigit, 4);
  
		  const bestChain = this.pickBetterChain(chain1, chain2);
		  if (!bestChain) continue;
  
		  const { startPos, endPos, endDigit, chainCellsSet } = bestChain;
  
		  // 规则：删除所有同时看见两端点的 endDigit（也就是 X）
		  for (let y = 0; y < SUDOKU_SIZE; y++) {
			for (let x = 0; x < SUDOKU_SIZE; x++) {
			  if (grid[y][x] !== 0) continue;
			  if (!candidates[y][x].includes(endDigit)) continue;
  
			  // 排除链上格子（含端点）
			  const keyCell = `${x},${y}`;
			  if (chainCellsSet.has(keyCell)) continue;
  
			  if (!this.canSee({ x, y }, startPos) || !this.canSee({ x, y }, endPos)) continue;
  
			  // 安全保护：不能删掉某个 unit 的“最后一个落点”
			  if (this.isLastPlaceInAnyUnit(grid, candidates, { x, y }, endDigit)) continue;
  
			  const elimKey = `${x},${y},${endDigit}`;
			  if (elimSeen.has(elimKey)) continue;
			  elimSeen.add(elimKey);
  
			  eliminations.push({
				position: { x, y },
				removed: [endDigit],
			  });
			}
		  }
		}
	  }
  
	  if (eliminations.length > 0) {
		return {
		  type: 'eliminate',
		  eliminations,
		  strategy: 'XY-Chain',
		  explanation: `找到XY-Chain，删除了 ${eliminations.length} 个单元格中的候选数。`,
		};
	  }
  
	  return null;
	}
  
	/**
	 * 正确的 XY-Chain（DFS）：
	 * startPos 是 bivalue {endDigit, otherDigit}
	 * 下一跳必须与当前格“可见”，并且是 bivalue 且包含 linkDigit
	 * 在下一格里，linkDigit 与“另一候选”形成强链接，新的 linkDigit = 另一候选
	 * 当某一步新的 linkDigit 回到 endDigit，且长度>=2（至少 2 个格）即可形成 XY-Chain
	 */
	findXYChainDFS(grid, candidates, startPos, endDigit, firstLinkDigit, maxCells) {
	  const startKey = `${startPos.x},${startPos.y}`;
	  const startCands = candidates[startPos.y][startPos.x];
	  if (startCands.length !== 2) return null;
	  if (!startCands.includes(endDigit) || !startCands.includes(firstLinkDigit)) return null;
  
	  const visited = new Set([startKey]);
	  const chainPath = [startPos]; // 只存格子序列
  
	  const dfs = (currentPos, linkDigit) => {
		if (chainPath.length >= maxCells) return null;
  
		// 找所有“下一格”：bivalue + 包含 linkDigit + 与 currentPos 可见
		for (let y = 0; y < SUDOKU_SIZE; y++) {
		  for (let x = 0; x < SUDOKU_SIZE; x++) {
			if (grid[y][x] !== 0) continue;
			const cands = candidates[y][x];
			if (cands.length !== 2) continue;
			if (!cands.includes(linkDigit)) continue;
  
			const nextPos = { x, y };
			const nextKey = `${x},${y}`;
			if (visited.has(nextKey)) continue;
			if (!this.canSee(currentPos, nextPos)) continue;
  
			const nextOther = cands[0] === linkDigit ? cands[1] : cands[0];
  
			// 走一步
			visited.add(nextKey);
			chainPath.push(nextPos);
  
			// 如果 nextOther 回到 endDigit，链闭合（端点 digit 相同）
			if (nextOther === endDigit && chainPath.length >= 2) {
			  const endPos = nextPos;
			  const chainCellsSet = new Set(chainPath.map(p => `${p.x},${p.y}`));
			  return {
				startPos,
				endPos,
				endDigit,
				length: chainPath.length,
				chainCellsSet
			  };
			}
  
			// 否则继续
			const found = dfs(nextPos, nextOther);
			if (found) return found;
  
			// 回溯
			chainPath.pop();
			visited.delete(nextKey);
		  }
		}
		return null;
	  };
  
	  return dfs(startPos, firstLinkDigit);
	}
  
	pickBetterChain(a, b) {
	  if (!a && !b) return null;
	  if (a && !b) return a;
	  if (!a && b) return b;
	  // 简单规则：更短优先（你也可以改成“消元更多优先”，但那需要预计算消元）
	  return a.length <= b.length ? a : b;
	}
  
	canSee(p1, p2) {
	  if (p1.x === p2.x) return true;
	  if (p1.y === p2.y) return true;
	  const b1x = Math.floor(p1.x / BOX_SIZE), b1y = Math.floor(p1.y / BOX_SIZE);
	  const b2x = Math.floor(p2.x / BOX_SIZE), b2y = Math.floor(p2.y / BOX_SIZE);
	  return b1x === b2x && b1y === b2y;
	}
  
	/**
	 * 防止“删掉某个 unit 中 digit 的最后一个可能位置”导致直接矛盾
	 */
	isLastPlaceInAnyUnit(grid, candidates, pos, digit) {
	  return (
		this.isLastInRow(grid, candidates, pos, digit) ||
		this.isLastInCol(grid, candidates, pos, digit) ||
		this.isLastInBox(grid, candidates, pos, digit)
	  );
	}
  
	isLastInRow(grid, candidates, pos, digit) {
	  let count = 0;
	  for (let x = 0; x < SUDOKU_SIZE; x++) {
		if (grid[pos.y][x] !== 0) continue;
		if (candidates[pos.y][x].includes(digit)) count++;
	  }
	  return count === 1 && candidates[pos.y][pos.x].includes(digit);
	}
  
	isLastInCol(grid, candidates, pos, digit) {
	  let count = 0;
	  for (let y = 0; y < SUDOKU_SIZE; y++) {
		if (grid[y][pos.x] !== 0) continue;
		if (candidates[y][pos.x].includes(digit)) count++;
	  }
	  return count === 1 && candidates[pos.y][pos.x].includes(digit);
	}
  
	isLastInBox(grid, candidates, pos, digit) {
	  const boxX = Math.floor(pos.x / BOX_SIZE) * BOX_SIZE;
	  const boxY = Math.floor(pos.y / BOX_SIZE) * BOX_SIZE;
	  let count = 0;
	  for (let y = boxY; y < boxY + BOX_SIZE; y++) {
		for (let x = boxX; x < boxX + BOX_SIZE; x++) {
		  if (grid[y][x] !== 0) continue;
		  if (candidates[y][x].includes(digit)) count++;
		}
	  }
	  return count === 1 && candidates[pos.y][pos.x].includes(digit);
	}
  }
  

export class Medusa3DStrategy extends BaseStrategy {
	constructor() { super('3D Medusa', 19, 'Diabolical'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 3D Medusa是Simple Colouring的扩展，使用多种颜色
		// 简化实现：使用X-Cycles和XY-Chain的组合
		const xCycles = new XCyclesStrategy();
		const result1 = xCycles.execute(grid, candidatesDict);
		if (result1) return result1;

		const xyChain = new XYChainStrategy();
		return xyChain.execute(grid, candidatesDict);
	}
}

export class JellyfishStrategy extends BaseStrategy {
	constructor() { super('Jellyfish', 20, 'Diabolical'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 检查行的Jellyfish（四行四列）
		for (let value = 1; value <= SUDOKU_SIZE; value++) {
			for (let row1 = 0; row1 < SUDOKU_SIZE - 3; row1++) {
				const cols1 = [];
				for (let x = 0; x < SUDOKU_SIZE; x++) {
					if (grid[row1][x] === 0 && candidates[row1][x].includes(value)) {
						cols1.push(x);
					}
				}
				if (cols1.length < 2 || cols1.length > 4) continue;

				for (let row2 = row1 + 1; row2 < SUDOKU_SIZE - 2; row2++) {
					const cols2 = [];
					for (let x = 0; x < SUDOKU_SIZE; x++) {
						if (grid[row2][x] === 0 && candidates[row2][x].includes(value)) {
							cols2.push(x);
						}
					}
					if (cols2.length < 2 || cols2.length > 4) continue;

					for (let row3 = row2 + 1; row3 < SUDOKU_SIZE - 1; row3++) {
						const cols3 = [];
						for (let x = 0; x < SUDOKU_SIZE; x++) {
							if (grid[row3][x] === 0 && candidates[row3][x].includes(value)) {
								cols3.push(x);
							}
						}
						if (cols3.length < 2 || cols3.length > 4) continue;

						for (let row4 = row3 + 1; row4 < SUDOKU_SIZE; row4++) {
							const cols4 = [];
							for (let x = 0; x < SUDOKU_SIZE; x++) {
								if (grid[row4][x] === 0 && candidates[row4][x].includes(value)) {
									cols4.push(x);
								}
							}
							if (cols4.length < 2 || cols4.length > 4) continue;

							// 检查四行的列集合是否有交集且正好是2-4列
							const allCols = new Set([...cols1, ...cols2, ...cols3, ...cols4]);
							if (allCols.size >= 2 && allCols.size <= 4) {
								// 检查每列是否至少在两行中出现
								for (const col of allCols) {
									let count = 0;
									if (cols1.includes(col)) count++;
									if (cols2.includes(col)) count++;
									if (cols3.includes(col)) count++;
									if (cols4.includes(col)) count++;
									if (count >= 2) {
										// 从该列的其他行中删除该候选数
										for (let y = 0; y < SUDOKU_SIZE; y++) {
											if (y !== row1 && y !== row2 && y !== row3 && y !== row4) {
												if (candidates[y][col].includes(value)) {
													eliminations.push({
														position: { x: col, y },
														removed: [value],
													});
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Jellyfish',
				explanation: `找到Jellyfish模式，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}

export class UniqueRectangles2PlusStrategy extends BaseStrategy {
	constructor() { super('Unique Rectangles 2+', 21, 'Diabolical'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 查找形成矩形的四个单元格（Unique Rectangles Type 2+）
		for (let r1 = 0; r1 < SUDOKU_SIZE - 1; r1++) {
			for (let c1 = 0; c1 < SUDOKU_SIZE - 1; c1++) {
				if (grid[r1][c1] !== 0) continue;

				for (let r2 = r1 + 1; r2 < SUDOKU_SIZE; r2++) {
					for (let c2 = c1 + 1; c2 < SUDOKU_SIZE; c2++) {
						if (grid[r2][c2] !== 0) continue;

						// 检查是否形成矩形：(r1,c1), (r1,c2), (r2,c1), (r2,c2)
						if (grid[r1][c2] === 0 && grid[r2][c1] === 0) {
							const cell1 = candidates[r1][c1];
							const cell2 = candidates[r1][c2];
							const cell3 = candidates[r2][c1];
							const cell4 = candidates[r2][c2];

							// Type 2: 三个单元格是双值，第四个单元格有额外候选数
							if (cell1.length === 2 && cell2.length === 2 && cell3.length === 2 && cell4.length > 2) {
								const set1 = new Set(cell1);
								const set2 = new Set(cell2);
								const set3 = new Set(cell3);

								if (this.setsEqual(set1, set2) && this.setsEqual(set2, set3)) {
									// 检查cell4是否包含所有三个单元格的候选数
									const commonValues = Array.from(set1);
									if (commonValues.every(v => cell4.includes(v))) {
										// 删除cell4中的额外候选数
										const toRemove = cell4.filter(c => !commonValues.includes(c));
										if (toRemove.length > 0) {
											eliminations.push({
												position: { x: c2, y: r2 },
												removed: toRemove,
											});
										}
									}
								}
							}

							// Type 3: 两个单元格是双值，另外两个有额外候选数
							if (cell1.length === 2 && cell2.length === 2 && cell3.length > 2 && cell4.length > 2) {
								const set1 = new Set(cell1);
								const set2 = new Set(cell2);

								if (this.setsEqual(set1, set2)) {
									const commonValues = Array.from(set1);
									// 检查cell3和cell4是否都包含共同候选数
									if (commonValues.every(v => cell3.includes(v)) && 
									    commonValues.every(v => cell4.includes(v))) {
										// 如果cell3和cell4在同一行/列/宫，可以删除额外候选数
										const sameRow = (r1 === r2);
										const sameCol = (c1 === c2);
										const sameBox = (Math.floor(r1 / BOX_SIZE) === Math.floor(r2 / BOX_SIZE) && 
										                 Math.floor(c1 / BOX_SIZE) === Math.floor(c2 / BOX_SIZE));

										if (sameRow || sameCol || sameBox) {
											const toRemove3 = cell3.filter(c => !commonValues.includes(c));
											const toRemove4 = cell4.filter(c => !commonValues.includes(c));
											
											if (toRemove3.length > 0) {
												eliminations.push({
													position: { x: c1, y: r2 },
													removed: toRemove3,
												});
											}
											if (toRemove4.length > 0) {
												eliminations.push({
													position: { x: c2, y: r2 },
													removed: toRemove4,
												});
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Unique Rectangles 2+',
				explanation: `找到唯一矩形类型2+，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}

	setsEqual(set1, set2) {
		if (set1.size !== set2.size) return false;
		for (const item of set1) {
			if (!set2.has(item)) return false;
		}
		return true;
	}
}

export class VariousStaticPatternsStrategy extends BaseStrategy {
	constructor() { super('Various static patterns', 22, 'Diabolical'); }

	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// Build candidates[y][x]
		const candidates = Array.from({ length: SUDOKU_SIZE }, (_, y) =>
			Array.from({ length: SUDOKU_SIZE }, (_, x) => {
				const key = `${x},${y}`;
				return candidatesDict[key] || [];
			})
		);

		// Use a map to dedupe eliminations: "x,y" -> Set(values)
		const elimMap = new Map();
		const addElim = (x, y, value) => {
			const k = `${x},${y}`;
			if (!elimMap.has(k)) elimMap.set(k, new Set());
			elimMap.get(k).add(value);
		};

		const colsWithCandidateInRow = (y, value) => {
			const cols = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				if (grid[y][x] === 0 && candidates[y][x].includes(value)) cols.push(x);
			}
			return cols;
		};

		const rowsWithCandidateInCol = (x, value) => {
			const rows = [];
			for (let y = 0; y < SUDOKU_SIZE; y++) {
				if (grid[y][x] === 0 && candidates[y][x].includes(value)) rows.push(y);
			}
			return rows;
		};

		const sameTwo = (a, b) =>
			a.length === 2 && b.length === 2 && a[0] === b[0] && a[1] === b[1];

		// ---- X-Wing by rows ----
		for (let value = 1; value <= SUDOKU_SIZE; value++) {
			// collect rows that have exactly 2 candidates for value
			const rowCols = [];
			for (let y = 0; y < SUDOKU_SIZE; y++) {
				const cols = colsWithCandidateInRow(y, value);
				if (cols.length === 2) rowCols.push({ y, cols: cols.slice().sort((a, b) => a - b) });
			}

			// pair rows
			for (let i = 0; i < rowCols.length; i++) {
				for (let j = i + 1; j < rowCols.length; j++) {
					const r1 = rowCols[i], r2 = rowCols[j];
					if (!sameTwo(r1.cols, r2.cols)) continue;

					const [cA, cB] = r1.cols;

					// eliminate value from these columns in all other rows (excluding r1.y and r2.y)
					for (let y = 0; y < SUDOKU_SIZE; y++) {
						if (y === r1.y || y === r2.y) continue;

						for (const x of [cA, cB]) {
							if (grid[y][x] !== 0) continue;
							if (!candidates[y][x].includes(value)) continue;
							addElim(x, y, value);
						}
					}
				}
			}
		}

		// ---- X-Wing by columns ----
		for (let value = 1; value <= SUDOKU_SIZE; value++) {
			const colRows = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const rows = rowsWithCandidateInCol(x, value);
				if (rows.length === 2) colRows.push({ x, rows: rows.slice().sort((a, b) => a - b) });
			}

			for (let i = 0; i < colRows.length; i++) {
				for (let j = i + 1; j < colRows.length; j++) {
					const c1 = colRows[i], c2 = colRows[j];
					if (!sameTwo(c1.rows, c2.rows)) continue;

					const [rA, rB] = c1.rows;

					// eliminate value from these rows in all other columns (excluding c1.x and c2.x)
					for (let x = 0; x < SUDOKU_SIZE; x++) {
						if (x === c1.x || x === c2.x) continue;

						for (const y of [rA, rB]) {
							if (grid[y][x] !== 0) continue;
							if (!candidates[y][x].includes(value)) continue;
							addElim(x, y, value);
						}
					}
				}
			}
		}

		// Convert elimMap -> eliminations array
		const eliminations = [];
		for (const [k, set] of elimMap.entries()) {
			const [xStr, yStr] = k.split(',');
			eliminations.push({
				position: { x: Number(xStr), y: Number(yStr) },
				removed: Array.from(set).sort((a, b) => a - b),
			});
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Various static patterns',
				explanation: `检测到 X-Wing（静态模式），删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}


export class ExtendedUniqueRectsStrategy extends BaseStrategy {
	constructor() { super('Extended Unique Rect\'s', 23, 'Diabolical'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 扩展唯一矩形：使用Unique Rectangles 2+的逻辑
		const uniqueRects2Plus = new UniqueRectangles2PlusStrategy();
		return uniqueRects2Plus.execute(grid, candidatesDict);
	}
}

export class HiddenUniqueRectsStrategy extends BaseStrategy {
	constructor() { super('Hidden Unique Rect\'s', 24, 'Diabolical'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 隐藏唯一矩形：查找隐藏的唯一矩形模式
		// 简化实现：使用Unique Rectangles的逻辑，但检查隐藏模式
		const uniqueRects1 = new UniqueRectangles1Strategy();
		const result1 = uniqueRects1.execute(grid, candidatesDict);
		if (result1) return result1;

		const uniqueRects2Plus = new UniqueRectangles2PlusStrategy();
		return uniqueRects2Plus.execute(grid, candidatesDict);
	}
}

export class WXYZWingStrategy extends BaseStrategy {
	constructor() { super('WXYZ Wing', 25, 'Diabolical'); }
  
	execute(grid, candidatesDict = null) {
	  if (!candidatesDict) return null;
  
	  // Build candidates[y][x]
	  const candidates = Array.from({ length: SUDOKU_SIZE }, (_, y) =>
		Array.from({ length: SUDOKU_SIZE }, (_, x) => {
		  const key = `${x},${y}`;
		  return candidatesDict[key] || [];
		})
	  );
  
	  const boxIndex = (x, y) =>
		Math.floor(y / BOX_SIZE) * BOX_SIZE + Math.floor(x / BOX_SIZE);
  
	  const sees = (x1, y1, x2, y2) => {
		if (x1 === x2 && y1 === y2) return true;
		return (
		  x1 === x2 ||
		  y1 === y2 ||
		  boxIndex(x1, y1) === boxIndex(x2, y2)
		);
	  };
  
	  const isEmpty = (x, y) => grid[y][x] === 0;
  
	  const elimKeySet = new Set();
	  const eliminations = [];
  
	  // Type 1 (narrow):
	  // hinge has 4 candidates; pick Z among them;
	  // find three bivalue cells {W,Z},{X,Z},{Y,Z} that each see the hinge.
	  for (let yH = 0; yH < SUDOKU_SIZE; yH++) {
		for (let xH = 0; xH < SUDOKU_SIZE; xH++) {
		  if (!isEmpty(xH, yH)) continue;
		  const hingeCands = candidates[yH][xH];
		  if (hingeCands.length !== 4) continue;
  
		  // Try each candidate as Z
		  for (let zi = 0; zi < hingeCands.length; zi++) {
			const Z = hingeCands[zi];
			const others = hingeCands.filter((_, i) => i !== zi); // [A,B,C]
			const [A, B, C] = others;
  
			// Collect possible wing cells for each pair {A,Z}, {B,Z}, {C,Z}
			const wingsA = [];
			const wingsB = [];
			const wingsC = [];
  
			for (let y = 0; y < SUDOKU_SIZE; y++) {
			  for (let x = 0; x < SUDOKU_SIZE; x++) {
				if (x === xH && y === yH) continue;
				if (!isEmpty(x, y)) continue;
				const c = candidates[y][x];
				if (c.length !== 2) continue;
				// wing must see hinge
				if (!sees(x, y, xH, yH)) continue;
  
				const hasZ = c.includes(Z);
				if (!hasZ) continue;
  
				if (c.includes(A)) wingsA.push({ x, y });
				if (c.includes(B)) wingsB.push({ x, y });
				if (c.includes(C)) wingsC.push({ x, y });
			  }
			}
  
			if (!wingsA.length || !wingsB.length || !wingsC.length) continue;
  
			// Enumerate combinations of 3 distinct wings (one from each list)
			for (const wA of wingsA) {
			  for (const wB of wingsB) {
				if (wB.x === wA.x && wB.y === wA.y) continue;
				for (const wC of wingsC) {
				  if ((wC.x === wA.x && wC.y === wA.y) || (wC.x === wB.x && wC.y === wB.y)) continue;
  
				  // Pattern cells
				  const pattern = [
					{ x: xH, y: yH },
					wA, wB, wC
				  ];
  
				  // Safety: Z must be non-restricted among Z locations in the pattern:
				  // i.e. not all Z cells mutually see each other.
				  // Here Z appears in hinge + all 3 wings (by construction).
				  let allPairsSee = true;
				  for (let i = 0; i < pattern.length; i++) {
					for (let j = i + 1; j < pattern.length; j++) {
					  if (!sees(pattern[i].x, pattern[i].y, pattern[j].x, pattern[j].y)) {
						allPairsSee = false;
						break;
					  }
					}
					if (!allPairsSee) break;
				  }
				  if (allPairsSee) continue; // Z restricted -> skip Type1 to avoid false eliminations
  
				  // Eliminate Z from any cell that can see ALL THREE wing cells (wA,wB,wC),
				  // excluding the 4 pattern cells themselves.
				  for (let y = 0; y < SUDOKU_SIZE; y++) {
					for (let x = 0; x < SUDOKU_SIZE; x++) {
					  if (!isEmpty(x, y)) continue;
					  if (!candidates[y][x].includes(Z)) continue;
  
					  // Skip pattern cells themselves
					  if (pattern.some(p => p.x === x && p.y === y)) continue;
  
					  const seeA = sees(x, y, wA.x, wA.y);
					  const seeB = sees(x, y, wB.x, wB.y);
					  const seeC = sees(x, y, wC.x, wC.y);
  
					  if (seeA && seeB && seeC) {
						const k = `${x},${y}:${Z}`;
						if (!elimKeySet.has(k)) {
						  elimKeySet.add(k);
						  eliminations.push({
							position: { x, y },
							removed: [Z],
						  });
						}
					  }
					}
				  }
				}
			  }
			}
		  }
		}
	  }
  
	  if (eliminations.length > 0) {
		return {
		  type: 'eliminate',
		  eliminations,
		  strategy: 'WXYZ Wing',
		  explanation: `找到 WXYZ-Wing(Type 1) 模式，删除了 ${eliminations.length} 个单元格中的候选数。`,
		};
	  }
  
	  return null;
	}
  }
  

export class AlignedPairExclusionStrategy extends BaseStrategy {
	constructor() { super('Aligned Pair Exclusion', 26, 'Diabolical'); }
  
	execute(grid, candidatesDict = null) {
	  if (!candidatesDict) return null;
  
	  const candidates = [];
	  for (let y = 0; y < SUDOKU_SIZE; y++) {
		candidates[y] = [];
		for (let x = 0; x < SUDOKU_SIZE; x++) {
		  const key = `${x},${y}`;
		  candidates[y][x] = candidatesDict[key] || [];
		}
	  }
  
	  const eliminations = [];
  
	  const sameBox = (x1, y1, x2, y2) =>
		Math.floor(x1 / BOX_SIZE) === Math.floor(x2 / BOX_SIZE) &&
		Math.floor(y1 / BOX_SIZE) === Math.floor(y2 / BOX_SIZE);
  
	  const canSee = (c1, c2) =>
		c1.x === c2.x || c1.y === c2.y || sameBox(c1.x, c1.y, c2.x, c2.y);
  
	  // 你原本只在“同一行”内找基对：我们先把它做对（Type 1 aligned pair）
	  for (let y = 0; y < SUDOKU_SIZE; y++) {
		const pairs = [];
		for (let x = 0; x < SUDOKU_SIZE; x++) {
		  if (grid[y][x] === 0 && candidates[y][x].length === 2) {
			pairs.push({ x, y, candidates: candidates[y][x] });
		  }
		}
  
		for (let i = 0; i < pairs.length - 1; i++) {
		  for (let j = i + 1; j < pairs.length; j++) {
			const p1 = pairs[i];
			const p2 = pairs[j];
  
			// 基对必须互相可见（在同一行里肯定可见，但这样写更稳）
			const sees = canSee(p1, p2);
			if (!sees) continue;
  
			const [a1, b1] = p1.candidates;
			const [a2, b2] = p2.candidates;
  
			// 允许的组合：在同一行/列/宫时，v1 不能等于 v2
			const allCombos = [
			  [a1, a2], [a1, b2], [b1, a2], [b1, b2]
			];
  
			const validCombos = allCombos.filter(([v1, v2]) => v1 !== v2);
  
			// 如果一个候选在任何有效组合里都没出现过，则该候选可删除
			const p1Allowed = new Set(validCombos.map(([v1]) => v1));
			const p2Allowed = new Set(validCombos.map(([, v2]) => v2));
  
			const removeFromP1 = p1.candidates.filter(v => !p1Allowed.has(v));
			const removeFromP2 = p2.candidates.filter(v => !p2Allowed.has(v));
  
			if (removeFromP1.length > 0) {
			  eliminations.push({
				position: { x: p1.x, y: p1.y },
				removed: removeFromP1,
			  });
			}
			if (removeFromP2.length > 0) {
			  eliminations.push({
				position: { x: p2.x, y: p2.y },
				removed: removeFromP2,
			  });
			}
		  }
		}
	  }
  
	  if (eliminations.length > 0) {
		return {
		  type: 'eliminate',
		  eliminations,
		  strategy: 'Aligned Pair Exclusion',
		  explanation: `Aligned Pair Exclusion（简化版：仅基对互斥组合）删除了 ${eliminations.length} 个单元格中的候选数。`,
		};
	  }
  
	  return null;
	}
  }
  

// 策略27-40: Extreme Strategies
export class ExocetStrategy extends BaseStrategy {
	constructor() { super('Exocet', 27, 'Extreme'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// Exocet是一个非常复杂的模式，需要特定的单元格配置
		// 简化实现：查找类似X-Wing但更复杂的模式
		const xWing = new XWingStrategy();
		const result1 = xWing.execute(grid, candidatesDict);
		if (result1) return result1;

		const swordfish = new SwordfishStrategy();
		return swordfish.execute(grid, candidatesDict);
	}
}

export class GroupedXCyclesStrategy extends BaseStrategy {
	constructor() { super('Grouped X-Cycles', 28, 'Extreme'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 分组X-Cycles：X-Cycles的扩展，允许分组单元格
		// 简化实现：使用X-Cycles的逻辑
		const xCycles = new XCyclesStrategy();
		return xCycles.execute(grid, candidatesDict);
	}
}

export class FinnedXWingStrategy extends BaseStrategy {
	constructor() { super('Finned X-Wing', 29, 'Extreme'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 检查行的Finned X-Wing
		for (let value = 1; value <= SUDOKU_SIZE; value++) {
			for (let row1 = 0; row1 < SUDOKU_SIZE - 1; row1++) {
				const cols1 = [];
				for (let x = 0; x < SUDOKU_SIZE; x++) {
					if (grid[row1][x] === 0 && candidates[row1][x].includes(value)) {
						cols1.push(x);
					}
				}
				if (cols1.length < 2 || cols1.length > 3) continue;

				for (let row2 = row1 + 1; row2 < SUDOKU_SIZE; row2++) {
					const cols2 = [];
					for (let x = 0; x < SUDOKU_SIZE; x++) {
						if (grid[row2][x] === 0 && candidates[row2][x].includes(value)) {
							cols2.push(x);
						}
					}
					if (cols2.length < 2 || cols2.length > 3) continue;

					// 检查是否形成X-Wing模式（两行两列）
					const commonCols = cols1.filter(c => cols2.includes(c));
					if (commonCols.length === 2) {
						// 标准X-Wing，检查是否有鳍
						const allCols = new Set([...cols1, ...cols2]);
						if (allCols.size === 3) {
							// 有鳍：第三列只在一行中出现
							const finCol = Array.from(allCols).find(c => !commonCols.includes(c));
							if (finCol !== undefined) {
								// 确定鳍在哪一行
								const finRow = cols1.includes(finCol) ? row1 : row2;
								const baseRow = cols1.includes(finCol) ? row2 : row1;
								
								// 检查鳍单元格是否与基础行在同一宫
								const finBox = Math.floor(finRow / BOX_SIZE) * BOX_SIZE + Math.floor(finCol / BOX_SIZE);
								const baseBox = Math.floor(baseRow / BOX_SIZE) * BOX_SIZE + Math.floor(commonCols[0] / BOX_SIZE);
								
								if (finBox === baseBox) {
									// 从基础行的其他列中删除该候选数
									for (let x = 0; x < SUDOKU_SIZE; x++) {
										if (!commonCols.includes(x) && x !== finCol) {
											if (candidates[baseRow][x].includes(value)) {
												eliminations.push({
													position: { x, y: baseRow },
													removed: [value],
												});
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Finned X-Wing',
				explanation: `找到Finned X-Wing模式，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}

export class FinnedSwordfishStrategy extends BaseStrategy {
	constructor() { super('Finned Swordfish', 30, 'Extreme'); }

	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// candidates[y][x]
		const candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];
		const seen = new Set(); // 去重：value + x + y

		const boxId = (x, y) =>
			Math.floor(y / BOX_SIZE) * BOX_SIZE + Math.floor(x / BOX_SIZE);

		// 行取向：选 3 行，候选分布在 3 个 baseCols + 1 个 finCol（总共4列）
		for (let value = 1; value <= SUDOKU_SIZE; value++) {
			for (let row1 = 0; row1 < SUDOKU_SIZE - 2; row1++) {
				const cols1 = [];
				for (let x = 0; x < SUDOKU_SIZE; x++) {
					if (grid[row1][x] === 0 && candidates[row1][x].includes(value)) cols1.push(x);
				}
				if (cols1.length < 2 || cols1.length > 4) continue;

				for (let row2 = row1 + 1; row2 < SUDOKU_SIZE - 1; row2++) {
					const cols2 = [];
					for (let x = 0; x < SUDOKU_SIZE; x++) {
						if (grid[row2][x] === 0 && candidates[row2][x].includes(value)) cols2.push(x);
					}
					if (cols2.length < 2 || cols2.length > 4) continue;

					for (let row3 = row2 + 1; row3 < SUDOKU_SIZE; row3++) {
						const cols3 = [];
						for (let x = 0; x < SUDOKU_SIZE; x++) {
							if (grid[row3][x] === 0 && candidates[row3][x].includes(value)) cols3.push(x);
						}
						if (cols3.length < 2 || cols3.length > 4) continue;

						const rows = [row1, row2, row3];
						const rowCols = [cols1, cols2, cols3];

						// finned swordfish：三行的列并集应该是 4（=3个baseCol + 1个finCol）
						const allCols = [...new Set([...cols1, ...cols2, ...cols3])];
						if (allCols.length !== 4) continue;

						// 统计每列在三行中出现次数
						const countByCol = new Map();
						for (const c of allCols) countByCol.set(c, 0);
						for (let i = 0; i < 3; i++) {
							for (const c of rowCols[i]) {
								if (countByCol.has(c)) countByCol.set(c, countByCol.get(c) + 1);
							}
						}

						const baseCols = [];
						const finCols = [];
						for (const c of allCols) {
							const cnt = countByCol.get(c);
							if (cnt >= 2) baseCols.push(c);
							else if (cnt === 1) finCols.push(c);
						}

						// 标准 finned swordfish：baseCols 必须是 3，finCols 必须是 1
						if (baseCols.length !== 3 || finCols.length !== 1) continue;

						const finCol = finCols[0];

						// finCol 出现在哪一行？
						let finRow = null;
						for (let i = 0; i < 3; i++) {
							if (rowCols[i].includes(finCol)) {
								finRow = rows[i];
								break;
							}
						}
						if (finRow === null) continue;

						// fin 所在宫
						const finBox = boxId(finCol, finRow);
						const finBoxColBand = Math.floor(finCol / BOX_SIZE);

						// 关键判定：finRow 里必须有至少一个 baseCol 也落在同一个 3×3 宫（同一宫列带）
						// 否则不是 finned（fin 必须“贴”在某个 baseCol 的宫里）
						const finRowCols = rowCols[rows.indexOf(finRow)];
						const baseColsInFinBox = baseCols.filter(
							(c) => finRowCols.includes(c) && Math.floor(c / BOX_SIZE) === finBoxColBand
						);
						if (baseColsInFinBox.length === 0) continue;

						// 正确删除：
						// 在 finBox 内，删除 baseColsInFinBox 这些列上的 value，排除 finRow
						const boxRowStart = Math.floor(finRow / BOX_SIZE) * BOX_SIZE;
						const boxColStart = finBoxColBand * BOX_SIZE;

						for (let y = boxRowStart; y < boxRowStart + BOX_SIZE; y++) {
							if (y === finRow) continue;

							for (const x of baseColsInFinBox) {
								// baseColsInFinBox 已确保在该 box 的列带内，但仍防御一下
								if (x < boxColStart || x >= boxColStart + BOX_SIZE) continue;

								if (grid[y][x] !== 0) continue;
								if (!candidates[y][x].includes(value)) continue;

								// 防护：避免删成空（你现在遇到的“删空”问题）
								if (candidates[y][x].length <= 1) continue;

								const key = `${value}:${x},${y}`;
								if (seen.has(key)) continue;
								seen.add(key);

								eliminations.push({
									position: { x, y },
									removed: [value],
								});
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Finned Swordfish',
				explanation: `找到Finned Swordfish模式：仅在 fin 所在宫内、对 swordfish 覆盖列进行删除（排除 fin 行），共删除 ${eliminations.length} 处候选数。`,
			};
		}

		return null;
	}
}


export class AlternInferenceChainsStrategy extends BaseStrategy {
	constructor() { super('Altern. Inference Chains', 31, 'Extreme'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 交替推理链：结合强链接和弱链接的链
		// 简化实现：使用XY-Chain和X-Cycles的组合
		const xyChain = new XYChainStrategy();
		const result1 = xyChain.execute(grid, candidatesDict);
		if (result1) return result1;

		const xCycles = new XCyclesStrategy();
		return xCycles.execute(grid, candidatesDict);
	}
}


export class AlmostLockedSetsStrategy extends BaseStrategy {
	constructor() {
	  super('Almost Locked Sets', 32, 'Extreme');
	}
  
	execute(grid, candidatesDict = null) {
	  if (!candidatesDict) return null;
  
	  const candidates = [];
	  for (let y = 0; y < SUDOKU_SIZE; y++) {
		candidates[y] = [];
		for (let x = 0; x < SUDOKU_SIZE; x++) {
		  const key = `${x},${y}`;
		  candidates[y][x] = (candidatesDict[key] || []).slice();
		}
	  }
  
	  const N = SUDOKU_SIZE;
	  const BOX = BOX_SIZE;
  
	  const cellKey = (c) => `${c.x},${c.y}`;
	  const unitKey = (cells) => cells.map(cellKey).sort().join('|');
	  const inBox = (x, y) => `${Math.floor(x / BOX)},${Math.floor(y / BOX)}`;
  
	  const sees = (a, b) => {
		if (a.x === b.x) return true;
		if (a.y === b.y) return true;
		return inBox(a.x, a.y) === inBox(b.x, b.y);
	  };
  
	  const unionSet = (arrays) => {
		const s = new Set();
		for (const arr of arrays) for (const d of arr) s.add(d);
		return s;
	  };
  
	  const buildALS = (cells) => {
		for (const c of cells) {
		  if (grid[c.y][c.x] !== 0) return null;
		  const cand = candidates[c.y][c.x];
		  if (!cand || cand.length === 0) return null;
		}
  
		const candUnion = unionSet(cells.map((c) => candidates[c.y][c.x]));
		if (candUnion.size !== cells.length + 1) return null;
  
		const digitCells = new Map();
		for (const d of candUnion) digitCells.set(d, []);
		for (const c of cells) {
		  for (const d of candidates[c.y][c.x]) {
			if (digitCells.has(d)) digitCells.get(d).push(c);
		  }
		}
  
		return { cells, candUnion, digitCells, id: unitKey(cells) };
	  };
  
	  const combinations = (arr, k) => {
		const res = [];
		const cur = [];
		const dfs = (start) => {
		  if (cur.length === k) { res.push(cur.slice()); return; }
		  for (let i = start; i <= arr.length - (k - cur.length); i++) {
			cur.push(arr[i]);
			dfs(i + 1);
			cur.pop();
		  }
		};
		dfs(0);
		return res;
	  };
  
	  // 27 units
	  const units = [];
  
	  for (let y = 0; y < N; y++) {
		const row = [];
		for (let x = 0; x < N; x++) row.push({ x, y });
		units.push(row);
	  }
  
	  for (let x = 0; x < N; x++) {
		const col = [];
		for (let y = 0; y < N; y++) col.push({ x, y });
		units.push(col);
	  }
  
	  for (let by = 0; by < BOX; by++) {
		for (let bx = 0; bx < BOX; bx++) {
		  const box = [];
		  for (let dy = 0; dy < BOX; dy++) {
			for (let dx = 0; dx < BOX; dx++) {
			  box.push({ x: bx * BOX + dx, y: by * BOX + dy });
			}
		  }
		  units.push(box);
		}
	  }
  
	  // enumerate ALS in each unit, size 1..4
	  const MAX_ALS_SIZE = 4;
	  const alsList = [];
	  const seenALS = new Set();
  
	  for (const unit of units) {
		const empties = unit.filter(
		  (c) => grid[c.y][c.x] === 0 && candidates[c.y][c.x] && candidates[c.y][c.x].length > 0
		);
  
		const maxSizeHere = Math.min(MAX_ALS_SIZE, empties.length);
		for (let size = 1; size <= maxSizeHere; size++) {
		  for (const comb of combinations(empties, size)) {
			const als = buildALS(comb);
			if (!als) continue;
  
			if (seenALS.has(als.id)) continue;
			seenALS.add(als.id);
			alsList.push(als);
		  }
		}
	  }
  
	  const isRCC = (alsA, alsB, d) => {
		const aCells = alsA.digitCells.get(d) || [];
		const bCells = alsB.digitCells.get(d) || [];
		if (aCells.length === 0 || bCells.length === 0) return false;
  
		// require all-to-all visibility
		for (const ca of aCells) {
		  for (const cb of bCells) {
			if (!sees(ca, cb)) return false;
		  }
		}
		return true;
	  };
  
	  const cellSetFromALS = (als) => {
		const s = new Set();
		for (const c of als.cells) s.add(cellKey(c));
		return s;
	  };
  
	  const seesAll = (t, cells) => {
		for (const c of cells) if (!sees(t, c)) return false;
		return true;
	  };
  
	  const eliminationMap = new Map(); // "x,y" -> Set(digits)
	  const addElim = (x, y, d) => {
		const key = `${x},${y}`;
		if (!eliminationMap.has(key)) eliminationMap.set(key, new Set());
		eliminationMap.get(key).add(d);
	  };
  
	  // apply ALS rules
	  for (let i = 0; i < alsList.length; i++) {
		for (let j = i + 1; j < alsList.length; j++) {
		  const A = alsList[i];
		  const B = alsList[j];
  
		  // quick prune: any cross visibility
		  let anySee = false;
		  for (const ca of A.cells) {
			for (const cb of B.cells) {
			  if (sees(ca, cb)) { anySee = true; break; }
			}
			if (anySee) break;
		  }
		  if (!anySee) continue;
  
		  // common digits
		  const common = [];
		  for (const d of A.candUnion) if (B.candUnion.has(d)) common.push(d);
		  if (common.length === 0) continue;
  
		  // RCC digits
		  const rcc = [];
		  for (const d of common) if (isRCC(A, B, d)) rcc.push(d);
		  if (rcc.length === 0) continue;
  
		  const ASet = cellSetFromALS(A);
		  const BSet = cellSetFromALS(B);
  
		  // Rule 1: singly linked ALS-XZ (exactly one RCC)
		  if (rcc.length === 1) {
			const X = rcc[0];
			const Zs = common.filter((d) => d !== X);
			if (Zs.length === 0) continue;
  
			for (const Z of Zs) {
			  const zCellsA = A.digitCells.get(Z) || [];
			  const zCellsB = B.digitCells.get(Z) || [];
			  const allZCells = zCellsA.concat(zCellsB);
			  if (allZCells.length === 0) continue;
  
			  for (let y = 0; y < N; y++) {
				for (let x = 0; x < N; x++) {
				  if (grid[y][x] !== 0) continue;
				  const k = `${x},${y}`;
				  if (ASet.has(k) || BSet.has(k)) continue;
				  if (!candidates[y][x].includes(Z)) continue;
  
				  const t = { x, y };
				  if (seesAll(t, allZCells)) addElim(x, y, Z);
				}
			  }
			}
		  }
  
		  // ✅ FIX: Double-Linked only when EXACTLY TWO RCC
		  if (rcc.length === 2) {
			const uniqueDigits = (base, other) => {
			  const res = [];
			  for (const d of base.candUnion) if (!other.candUnion.has(d)) res.push(d);
			  return res;
			};
  
			const applyUniqueElims = (base, baseSet, uniq) => {
			  for (const d of uniq) {
				const occ = base.digitCells.get(d) || [];
				if (occ.length === 0) continue;
  
				for (let y = 0; y < N; y++) {
				  for (let x = 0; x < N; x++) {
					if (grid[y][x] !== 0) continue;
					const k = `${x},${y}`;
					if (baseSet.has(k)) continue;
					if (!candidates[y][x].includes(d)) continue;
  
					const t = { x, y };
					if (seesAll(t, occ)) addElim(x, y, d);
				  }
				}
			  }
			};
  
			applyUniqueElims(A, ASet, uniqueDigits(A, B));
			applyUniqueElims(B, BSet, uniqueDigits(B, A));
		  }
		}
	  }
  
	  // pack eliminations + ✅ safety: don't allow any cell to go empty
	  const eliminations = [];
	  for (const [key, ds] of eliminationMap.entries()) {
		const [xs, ys] = key.split(',');
		const x = parseInt(xs, 10);
		const y = parseInt(ys, 10);
  
		const removed = Array.from(ds).filter((d) => candidates[y][x].includes(d));
		if (removed.length === 0) continue;
  
		// ✅ safety check
		const remainCount = candidates[y][x].length - removed.length;
		if (remainCount <= 0) {
		  // If this happens, something is wrong (coords/type/rule triggered incorrectly).
		  // Don't return any eliminations to avoid nuking candidates.
		  return null;
		}
  
		eliminations.push({ position: { x, y }, removed });
	  }
  
	  if (eliminations.length > 0) {
		return {
		  type: 'eliminate',
		  eliminations,
		  strategy: 'Almost Locked Sets',
		  explanation: `使用 ALS-XZ（单链接）与 Double-Linked（双链接）规则找到可删除项，共删除 ${eliminations.length} 个单元格中的候选数。`,
		};
	  }
  
	  return null;
	}
  }
   

export class DeathBlossomStrategy extends BaseStrategy {
	constructor() { super('Death Blossom', 33, 'Extreme'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 死亡之花：几乎锁定集合的特殊应用
		// 简化实现：使用Almost Locked Sets的逻辑
		const als = new AlmostLockedSetsStrategy();
		return als.execute(grid, candidatesDict);
	}
}

export class SudeCoqStrategy extends BaseStrategy {
	constructor() { super('Sue-de-Coq', 34, 'Extreme'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// Sue-de-Coq：行/列和宫的交集模式
		// 简化实现：查找行/列和宫的交集中有特殊模式的单元格
		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 检查每行和其所在宫的交集
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			const boxRow = Math.floor(y / BOX_SIZE);
			const boxStartRow = boxRow * BOX_SIZE;
			const boxEndRow = boxStartRow + BOX_SIZE;

			// 查找行和宫的交集单元格
			const intersectionCells = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const boxCol = Math.floor(x / BOX_SIZE);
				if (grid[y][x] === 0) {
					intersectionCells.push({ x, y, candidates: candidates[y][x] });
				}
			}

			// 查找宫中的其他单元格
			const boxOtherCells = [];
			for (let row = boxStartRow; row < boxEndRow; row++) {
				if (row === y) continue;
				for (let x = 0; x < SUDOKU_SIZE; x++) {
					const boxCol = Math.floor(x / BOX_SIZE);
					if (grid[row][x] === 0) {
						boxOtherCells.push({ x, y: row, candidates: candidates[row][x] });
					}
				}
			}

			// 检查Sue-de-Coq模式：交集单元格和宫其他单元格的候选数有特殊关系
			if (intersectionCells.length >= 2 && boxOtherCells.length >= 2) {
				const intersectionCandidates = new Set();
				intersectionCells.forEach(cell => {
					cell.candidates.forEach(c => intersectionCandidates.add(c));
				});

				const boxOtherCandidates = new Set();
				boxOtherCells.forEach(cell => {
					cell.candidates.forEach(c => boxOtherCandidates.add(c));
				});

				// 如果交集候选数和宫其他候选数有重叠，可以删除某些候选数
				const common = new Set([...intersectionCandidates].filter(c => boxOtherCandidates.has(c)));
				if (common.size > 0) {
					// 删除行中非交集单元格的候选数
					for (let x = 0; x < SUDOKU_SIZE; x++) {
						const inIntersection = intersectionCells.some(cell => cell.x === x);
						if (!inIntersection && grid[y][x] === 0) {
							const toRemove = candidates[y][x].filter(c => common.has(c));
							if (toRemove.length > 0) {
								eliminations.push({
									position: { x, y },
									removed: toRemove,
								});
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Sue-de-Coq',
				explanation: `找到Sue-de-Coq模式，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}

export class DigitForcingChainsStrategy extends BaseStrategy {
	constructor() { super('Digit Forcing Chains', 35, 'Extreme'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 数字强制链：通过假设某个数字的值，推导出矛盾或确定值
		// 简化实现：使用XY-Chain的逻辑
		const xyChain = new XYChainStrategy();
		return xyChain.execute(grid, candidatesDict);
	}
}

export class NishioForcingChainsStrategy extends BaseStrategy {
	constructor() { super('Nishio Forcing Chains', 36, 'Extreme'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// Nishio强制链：通过假设某个单元格的值，推导出矛盾
		// 简化实现：查找会导致矛盾的候选数
		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 简化实现：查找双值单元格，如果其中一个值会导致矛盾，删除另一个值
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				if (grid[y][x] !== 0 || candidates[y][x].length !== 2) continue;

				const [a, b] = candidates[y][x];

				// 检查假设a会导致矛盾
				const conflictA = this.wouldCauseConflict(grid, candidates, { x, y }, a);
				if (conflictA) {
					eliminations.push({
						position: { x, y },
						removed: [a],
					});
					continue;
				}

				// 检查假设b会导致矛盾
				const conflictB = this.wouldCauseConflict(grid, candidates, { x, y }, b);
				if (conflictB) {
					eliminations.push({
						position: { x, y },
						removed: [b],
					});
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Nishio Forcing Chains',
				explanation: `找到Nishio强制链，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}

	wouldCauseConflict(grid, candidates, pos, value) {
		// 简化检查：假设该单元格填入value，检查是否会导致行/列/宫中有重复
		const { x, y } = pos;

		// 检查行
		for (let i = 0; i < SUDOKU_SIZE; i++) {
			if (i !== x && grid[y][i] === value) return true;
		}

		// 检查列
		for (let i = 0; i < SUDOKU_SIZE; i++) {
			if (i !== y && grid[i][x] === value) return true;
		}

		// 检查宫
		const startRow = Math.floor(y / BOX_SIZE) * BOX_SIZE;
		const startCol = Math.floor(x / BOX_SIZE) * BOX_SIZE;
		for (let row = startRow; row < startRow + BOX_SIZE; row++) {
			for (let col = startCol; col < startCol + BOX_SIZE; col++) {
				if ((row !== y || col !== x) && grid[row][col] === value) return true;
			}
		}

		return false;
	}
}

export class CellForcingChainsStrategy extends BaseStrategy {
	constructor() { super('Cell Forcing Chains', 37, 'Extreme'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 单元格强制链：通过假设某个单元格的值，推导出其他单元格的值
		// 简化实现：使用Nishio的逻辑
		const nishio = new NishioForcingChainsStrategy();
		return nishio.execute(grid, candidatesDict);
	}
}

export class UnitForcingChainsStrategy extends BaseStrategy {
	constructor() { super('Unit Forcing Chains', 38, 'Extreme'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 单元强制链：通过假设某个单元（行/列/宫）中某个数字的位置，推导出矛盾
		// 简化实现：使用Digit Forcing Chains的逻辑
		const digitForcing = new DigitForcingChainsStrategy();
		return digitForcing.execute(grid, candidatesDict);
	}
}

export class PatternOverlayMethodStrategy extends BaseStrategy {
	constructor() { super('Pattern Overlay Method', 39, 'Extreme'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 模式覆盖方法：通过覆盖所有可能的模式来找到解
		// 这是一个非常复杂的策略，简化实现：使用其他高级策略的组合
		const xCycles = new XCyclesStrategy();
		const result1 = xCycles.execute(grid, candidatesDict);
		if (result1) return result1;

		const xyChain = new XYChainStrategy();
		const result2 = xyChain.execute(grid, candidatesDict);
		if (result2) return result2;

		const als = new AlmostLockedSetsStrategy();
		return als.execute(grid, candidatesDict);
	}
}

export class QuadForcingChainsStrategy extends BaseStrategy {
	constructor() { super('Quad Forcing Chains', 40, 'Extreme'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 四元强制链：四个单元格的强制链
		// 简化实现：使用Cell Forcing Chains的逻辑
		const cellForcing = new CellForcingChainsStrategy();
		return cellForcing.execute(grid, candidatesDict);
	}
}

// 策略41: Trial and Error
export class BowmansBingoStrategy extends BaseStrategy {
	constructor() { super('Bowman\'s Bingo', 41, 'Trial and Error'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// Bowman's Bingo：试错法，通过尝试填入数字来找到解
		// 这是一个非常复杂的策略，需要回溯算法
		// 简化实现：使用Nishio Forcing Chains的逻辑
		const nishio = new NishioForcingChainsStrategy();
		return nishio.execute(grid, candidatesDict);
	}
}
