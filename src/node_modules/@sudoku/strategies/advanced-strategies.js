import { BaseStrategy } from './base-strategy.js';
import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';

/**
 * 策略6: BUG (Bivalue Universal Grave)
 * 当所有未解决的单元格都只有两个候选数时，如果出现BUG模式，可以删除某些候选数
 */
export class BUGStrategy extends BaseStrategy {
	constructor() {
		super('BUG', 6, 'Tough');
	}

	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		// 检查是否所有未解决单元格都只有两个候选数
		let allBivalue = true;
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				if (grid[y][x] === 0 && candidates[y][x].length !== 2) {
					allBivalue = false;
					break;
				}
			}
			if (!allBivalue) break;
		}

		if (!allBivalue) return null;

		// 查找BUG模式：某个数字在行/列/宫中出现奇数次
		const eliminations = [];

		for (let value = 1; value <= SUDOKU_SIZE; value++) {
			// 检查行
			for (let y = 0; y < SUDOKU_SIZE; y++) {
				let count = 0;
				let bugCell = null;
				for (let x = 0; x < SUDOKU_SIZE; x++) {
					if (grid[y][x] === 0 && candidates[y][x].includes(value)) {
						count++;
						if (candidates[y][x].length === 2) {
							bugCell = { x, y };
						}
					}
				}
				// 如果出现奇数次且只有一个双值单元格包含该数字
				if (count % 2 === 1 && bugCell) {
					// 删除该单元格中的另一个候选数
					const otherCandidate = candidates[bugCell.y][bugCell.x].find(c => c !== value);
					if (otherCandidate) {
						eliminations.push({
							position: bugCell,
							removed: [otherCandidate],
						});
					}
				}
			}

			// 检查列
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				let count = 0;
				let bugCell = null;
				for (let y = 0; y < SUDOKU_SIZE; y++) {
					if (grid[y][x] === 0 && candidates[y][x].includes(value)) {
						count++;
						if (candidates[y][x].length === 2) {
							bugCell = { x, y };
						}
					}
				}
				if (count % 2 === 1 && bugCell) {
					const otherCandidate = candidates[bugCell.y][bugCell.x].find(c => c !== value);
					if (otherCandidate) {
						eliminations.push({
							position: bugCell,
							removed: [otherCandidate],
						});
					}
				}
			}

			// 检查宫
			for (let boxRow = 0; boxRow < BOX_SIZE; boxRow++) {
				for (let boxCol = 0; boxCol < BOX_SIZE; boxCol++) {
					let count = 0;
					let bugCell = null;
					for (let y = boxRow * BOX_SIZE; y < (boxRow + 1) * BOX_SIZE; y++) {
						for (let x = boxCol * BOX_SIZE; x < (boxCol + 1) * BOX_SIZE; x++) {
							if (grid[y][x] === 0 && candidates[y][x].includes(value)) {
								count++;
								if (candidates[y][x].length === 2) {
									bugCell = { x, y };
								}
							}
						}
					}
					if (count % 2 === 1 && bugCell) {
						const otherCandidate = candidates[bugCell.y][bugCell.x].find(c => c !== value);
						if (otherCandidate) {
							eliminations.push({
								position: bugCell,
								removed: [otherCandidate],
							});
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'BUG',
				explanation: `找到BUG模式，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}

/**
 * 策略7: X-Wing
 * 当某个数字在两行（或两列）中，都只出现在相同的两列（或两行）时，可以从这两列（或两行）的其他单元格中删除该数字
 */
export class XWingStrategy extends BaseStrategy {
	constructor() {
		super('X-Wing', 7, 'Tough');
	}

	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 检查行的X-Wing
		for (let value = 1; value <= SUDOKU_SIZE; value++) {
			for (let row1 = 0; row1 < SUDOKU_SIZE - 1; row1++) {
				const cols1 = [];
				for (let x = 0; x < SUDOKU_SIZE; x++) {
					if (grid[row1][x] === 0 && candidates[row1][x].includes(value)) {
						cols1.push(x);
					}
				}
				if (cols1.length !== 2) continue;

				for (let row2 = row1 + 1; row2 < SUDOKU_SIZE; row2++) {
					const cols2 = [];
					for (let x = 0; x < SUDOKU_SIZE; x++) {
						if (grid[row2][x] === 0 && candidates[row2][x].includes(value)) {
							cols2.push(x);
						}
					}
					if (cols2.length !== 2) continue;

					// 检查是否相同的两列
					if (cols1[0] === cols2[0] && cols1[1] === cols2[1]) {
						// 从这两列的其他行中删除该候选数
						for (let y = 0; y < SUDOKU_SIZE; y++) {
							if (y !== row1 && y !== row2) {
								if (candidates[y][cols1[0]].includes(value)) {
									eliminations.push({
										position: { x: cols1[0], y },
										removed: [value],
									});
								}
								if (candidates[y][cols1[1]].includes(value)) {
									eliminations.push({
										position: { x: cols1[1], y },
										removed: [value],
									});
								}
							}
						}
					}
				}
			}

			// 检查列的X-Wing
			for (let col1 = 0; col1 < SUDOKU_SIZE - 1; col1++) {
				const rows1 = [];
				for (let y = 0; y < SUDOKU_SIZE; y++) {
					if (grid[y][col1] === 0 && candidates[y][col1].includes(value)) {
						rows1.push(y);
					}
				}
				if (rows1.length !== 2) continue;

				for (let col2 = col1 + 1; col2 < SUDOKU_SIZE; col2++) {
					const rows2 = [];
					for (let y = 0; y < SUDOKU_SIZE; y++) {
						if (grid[y][col2] === 0 && candidates[y][col2].includes(value)) {
							rows2.push(y);
						}
					}
					if (rows2.length !== 2) continue;

					if (rows1[0] === rows2[0] && rows1[1] === rows2[1]) {
						// 从这两行的其他列中删除该候选数
						for (let x = 0; x < SUDOKU_SIZE; x++) {
							if (x !== col1 && x !== col2) {
								if (candidates[rows1[0]][x].includes(value)) {
									eliminations.push({
										position: { x, y: rows1[0] },
										removed: [value],
									});
								}
								if (candidates[rows1[1]][x].includes(value)) {
									eliminations.push({
										position: { x, y: rows1[1] },
										removed: [value],
									});
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'X-Wing',
				explanation: `找到X-Wing模式，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}

/**
 * 策略8: Unique Rectangles Type 1
 * 当四个单元格形成矩形，且都只有两个相同的候选数时，如果其中三个单元格在同一行/列/宫中，可以删除第四个单元格的候选数
 */
export class UniqueRectangles1Strategy extends BaseStrategy {
	constructor() {
		super('Unique Rectangles 1', 8, 'Tough');
	}

	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 查找形成矩形的四个单元格
		for (let r1 = 0; r1 < SUDOKU_SIZE - 1; r1++) {
			for (let c1 = 0; c1 < SUDOKU_SIZE - 1; c1++) {
				if (grid[r1][c1] !== 0) continue;

				for (let r2 = r1 + 1; r2 < SUDOKU_SIZE; r2++) {
					for (let c2 = c1 + 1; c2 < SUDOKU_SIZE; c2++) {
						if (grid[r2][c2] !== 0) continue;

						// 检查是否形成矩形：(r1,c1), (r1,c2), (r2,c1), (r2,c2)
						if (grid[r1][c2] === 0 && grid[r2][c1] === 0) {
							const cell1 = candidates[r1][c1];
							const cell2 = candidates[r1][c2];
							const cell3 = candidates[r2][c1];
							const cell4 = candidates[r2][c2];

							// 检查是否都是双值单元格且候选数相同
							if (cell1.length === 2 && cell2.length === 2 && 
							    cell3.length === 2 && cell4.length === 2) {
								const set1 = new Set(cell1);
								const set2 = new Set(cell2);
								const set3 = new Set(cell3);
								const set4 = new Set(cell4);

								// 检查是否所有单元格都有相同的两个候选数
								if (set1.size === 2 && this.setsEqual(set1, set2) && 
								    this.setsEqual(set2, set3) && this.setsEqual(set3, set4)) {
									// 检查是否在同一宫
									const box1 = Math.floor(r1 / BOX_SIZE) * BOX_SIZE + Math.floor(c1 / BOX_SIZE);
									const box2 = Math.floor(r1 / BOX_SIZE) * BOX_SIZE + Math.floor(c2 / BOX_SIZE);
									const box3 = Math.floor(r2 / BOX_SIZE) * BOX_SIZE + Math.floor(c1 / BOX_SIZE);
									const box4 = Math.floor(r2 / BOX_SIZE) * BOX_SIZE + Math.floor(c2 / BOX_SIZE);

									// 如果三个单元格在同一宫，删除第四个单元格的候选数
									if (box1 === box2 && box2 === box3 && box3 !== box4) {
										eliminations.push({
											position: { x: c2, y: r2 },
											removed: [...cell4],
										});
									} else if (box1 === box2 && box2 === box4 && box4 !== box3) {
										eliminations.push({
											position: { x: c1, y: r2 },
											removed: [...cell3],
										});
									} else if (box1 === box3 && box3 === box4 && box4 !== box2) {
										eliminations.push({
											position: { x: c2, y: r1 },
											removed: [...cell2],
										});
									} else if (box2 === box3 && box3 === box4 && box4 !== box1) {
										eliminations.push({
											position: { x: c1, y: r1 },
											removed: [...cell1],
										});
									}
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Unique Rectangles 1',
				explanation: `找到唯一矩形类型1，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}

	setsEqual(set1, set2) {
		if (set1.size !== set2.size) return false;
		for (const item of set1) {
			if (!set2.has(item)) return false;
		}
		return true;
	}
}

/**
 * 策略9: Chute Remote Pairs
 * 当两个单元格形成远程数对时，可以删除它们之间的候选数
 */
export class ChuteRemotePairsStrategy extends BaseStrategy {
	constructor() {
		super('Chute Remote Pairs', 9, 'Tough');
	}

	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 查找远程数对：两个数对通过链连接
		// 简化实现：查找在同一行/列/宫中的数对
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			const pairs = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				if (grid[y][x] === 0 && candidates[y][x].length === 2) {
					pairs.push({ x, y, candidates: candidates[y][x] });
				}
			}

			// 查找相同的数对
			for (let i = 0; i < pairs.length - 1; i++) {
				for (let j = i + 1; j < pairs.length; j++) {
					const set1 = new Set(pairs[i].candidates);
					const set2 = new Set(pairs[j].candidates);
					
					if (set1.size === 2 && this.setsEqual(set1, set2)) {
						// 找到数对，检查它们之间是否有其他单元格
						const pairValues = Array.from(set1);
						const x1 = pairs[i].x;
						const x2 = pairs[j].x;
						
						// 如果两个数对之间有其他单元格，可以删除这些单元格中的数对候选数
						const minX = Math.min(x1, x2);
						const maxX = Math.max(x1, x2);
						
						for (let x = minX + 1; x < maxX; x++) {
							if (grid[y][x] === 0 && candidates[y][x].length > 0) {
								const toRemove = candidates[y][x].filter(c => pairValues.includes(c));
								if (toRemove.length > 0) {
									eliminations.push({
										position: { x, y },
										removed: toRemove,
									});
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Chute Remote Pairs',
				explanation: `找到远程数对，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}

	setsEqual(set1, set2) {
		if (set1.size !== set2.size) return false;
		for (const item of set1) {
			if (!set2.has(item)) return false;
		}
		return true;
	}
}

/**
 * 策略10: W-Wing
 * 当两个单元格通过一个强链接连接，且它们有相同的两个候选数时，可以删除某些候选数
 */
export class WWingStrategy extends BaseStrategy {
	constructor() {
		super('W-Wing', 10, 'Tough');
	}

	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 查找W-Wing模式
		// 需要找到两个双值单元格，它们有相同的两个候选数，且通过另一个单元格连接
		for (let y1 = 0; y1 < SUDOKU_SIZE; y1++) {
			for (let x1 = 0; x1 < SUDOKU_SIZE; x1++) {
				if (grid[y1][x1] !== 0 || candidates[y1][x1].length !== 2) continue;

				for (let y2 = 0; y2 < SUDOKU_SIZE; y2++) {
					for (let x2 = 0; x2 < SUDOKU_SIZE; x2++) {
						if ((y1 === y2 && x1 === x2) || grid[y2][x2] !== 0) continue;
						if (candidates[y2][x2].length !== 2) continue;

						// 检查是否有相同的候选数
						const set1 = new Set(candidates[y1][x1]);
						const set2 = new Set(candidates[y2][x2]);
						if (!this.setsEqual(set1, set2)) continue;

						const [a, b] = Array.from(set1);

						// 查找连接单元格（包含a或b，且与两个单元格都相关）
						for (let y3 = 0; y3 < SUDOKU_SIZE; y3++) {
							for (let x3 = 0; x3 < SUDOKU_SIZE; x3++) {
								if (grid[y3][x3] !== 0) continue;
								if ((y3 === y1 && x3 === x1) || (y3 === y2 && x3 === x2)) continue;

								const cell3 = candidates[y3][x3];
								if (!cell3.includes(a) && !cell3.includes(b)) continue;

								// 检查是否与cell1和cell2都相关（同行/列/宫）
								const related1 = (y3 === y1 || x3 === x1 || 
									(Math.floor(y3 / BOX_SIZE) === Math.floor(y1 / BOX_SIZE) && 
									 Math.floor(x3 / BOX_SIZE) === Math.floor(x1 / BOX_SIZE)));
								const related2 = (y3 === y2 || x3 === x2 || 
									(Math.floor(y3 / BOX_SIZE) === Math.floor(y2 / BOX_SIZE) && 
									 Math.floor(x3 / BOX_SIZE) === Math.floor(x2 / BOX_SIZE)));

								if (related1 && related2) {
									// 找到W-Wing，删除相关单元格中的候选数
									// 简化实现：删除与两个单元格都相关的单元格中的另一个候选数
									const otherValue = cell3.includes(a) ? b : a;
									
									// 查找与cell1和cell2都相关的单元格
									for (let y = 0; y < SUDOKU_SIZE; y++) {
										for (let x = 0; x < SUDOKU_SIZE; x++) {
											if (grid[y][x] !== 0) continue;
											const rel1 = (y === y1 || x === x1 || 
												(Math.floor(y / BOX_SIZE) === Math.floor(y1 / BOX_SIZE) && 
												 Math.floor(x / BOX_SIZE) === Math.floor(x1 / BOX_SIZE)));
											const rel2 = (y === y2 || x === x2 || 
												(Math.floor(y / BOX_SIZE) === Math.floor(y2 / BOX_SIZE) && 
												 Math.floor(x / BOX_SIZE) === Math.floor(x2 / BOX_SIZE)));
											
											if (rel1 && rel2 && candidates[y][x].includes(otherValue)) {
												eliminations.push({
													position: { x, y },
													removed: [otherValue],
												});
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'W-Wing',
				explanation: `找到W-Wing模式，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}

	setsEqual(set1, set2) {
		if (set1.size !== set2.size) return false;
		for (const item of set1) {
			if (!set2.has(item)) return false;
		}
		return true;
	}
}

/**
 * 策略11: Y-Wing
 * 当三个单元格形成Y形连接，且满足特定条件时，可以删除某些候选数
 */
export class YWingStrategy extends BaseStrategy {
	constructor() {
		super('Y-Wing', 11, 'Tough');
	}

	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 查找Y-Wing模式：三个双值单元格，形成Y形
		for (let y1 = 0; y1 < SUDOKU_SIZE; y1++) {
			for (let x1 = 0; x1 < SUDOKU_SIZE; x1++) {
				if (grid[y1][x1] !== 0 || candidates[y1][x1].length !== 2) continue;
				const [a, b] = candidates[y1][x1];

				// 查找第二个单元格（包含a和c）
				for (let y2 = 0; y2 < SUDOKU_SIZE; y2++) {
					for (let x2 = 0; x2 < SUDOKU_SIZE; x2++) {
						if ((y1 === y2 && x1 === x2) || grid[y2][x2] !== 0) continue;
						if (candidates[y2][x2].length !== 2) continue;
						if (!candidates[y2][x2].includes(a)) continue;

						const c = candidates[y2][x2].find(v => v !== a);
						if (!c) continue;

						// 查找第三个单元格（包含b和c）
						for (let y3 = 0; y3 < SUDOKU_SIZE; y3++) {
							for (let x3 = 0; x3 < SUDOKU_SIZE; x3++) {
								if ((y1 === y3 && x1 === x3) || (y2 === y3 && x2 === x3)) continue;
								if (grid[y3][x3] !== 0) continue;
								if (candidates[y3][x3].length !== 2) continue;
								if (!candidates[y3][x3].includes(b) || !candidates[y3][x3].includes(c)) continue;

								// 检查cell2和cell3是否都与cell1相关
								const rel12 = (y1 === y2 || x1 === x2 || 
									(Math.floor(y1 / BOX_SIZE) === Math.floor(y2 / BOX_SIZE) && 
									 Math.floor(x1 / BOX_SIZE) === Math.floor(x2 / BOX_SIZE)));
								const rel13 = (y1 === y3 || x1 === x3 || 
									(Math.floor(y1 / BOX_SIZE) === Math.floor(y3 / BOX_SIZE) && 
									 Math.floor(x1 / BOX_SIZE) === Math.floor(x3 / BOX_SIZE)));

								if (rel12 && rel13) {
									// 查找与cell2和cell3都相关的单元格，删除c
									for (let y = 0; y < SUDOKU_SIZE; y++) {
										for (let x = 0; x < SUDOKU_SIZE; x++) {
											if (grid[y][x] !== 0) continue;
											const rel2 = (y === y2 || x === x2 || 
												(Math.floor(y / BOX_SIZE) === Math.floor(y2 / BOX_SIZE) && 
												 Math.floor(x / BOX_SIZE) === Math.floor(x2 / BOX_SIZE)));
											const rel3 = (y === y3 || x === x3 || 
												(Math.floor(y / BOX_SIZE) === Math.floor(y3 / BOX_SIZE) && 
												 Math.floor(x / BOX_SIZE) === Math.floor(x3 / BOX_SIZE)));

											if (rel2 && rel3 && candidates[y][x].includes(c)) {
												eliminations.push({
													position: { x, y },
													removed: [c],
												});
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Y-Wing',
				explanation: `找到Y-Wing模式，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}

/**
 * 策略12: Rectangle Elimination
 * 矩形消除策略
 */
export class RectangleEliminationStrategy extends BaseStrategy {
	constructor() {
		super('Rectangle Elimination', 12, 'Tough');
	}

	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 使用Unique Rectangles 2+的逻辑
		const uniqueRects2Plus = new UniqueRectangles2PlusStrategy();
		return uniqueRects2Plus.execute(grid, candidatesDict);
	}
}

/**
 * 策略13: Simple Colouring
 * 简单着色策略，通过给候选数着色来找到强链接和弱链接
 */
export class SimpleColouringStrategy extends BaseStrategy {
	constructor() {
		super('Simple Colouring', 13, 'Tough');
	}

	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 简化实现：使用X-Cycles的逻辑
		const xCycles = new XCyclesStrategy();
		return xCycles.execute(grid, candidatesDict);
	}
}

/**
 * 策略14: Quads Naked+Hidden
 * 四数组（显式和隐藏）
 */
export class QuadsStrategy extends BaseStrategy {
	constructor() {
		super('Quads Naked+Hidden', 14, 'Tough');
	}

	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 检查显式四数组（行）
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			const quadCells = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				if (grid[y][x] === 0 && candidates[y][x].length >= 2 && candidates[y][x].length <= 4) {
					quadCells.push({ x, y, candidates: candidates[y][x] });
				}
			}

			// 查找四个单元格，它们的候选数并集正好是4个数字
			for (let i = 0; i < quadCells.length - 3; i++) {
				for (let j = i + 1; j < quadCells.length - 2; j++) {
					for (let k = j + 1; k < quadCells.length - 1; k++) {
						for (let l = k + 1; l < quadCells.length; l++) {
							const allCandidates = new Set([
								...quadCells[i].candidates,
								...quadCells[j].candidates,
								...quadCells[k].candidates,
								...quadCells[l].candidates,
							]);

							if (allCandidates.size === 4) {
								const quadValues = Array.from(allCandidates);
								// 删除其他单元格中的四数组候选数
								for (let x = 0; x < SUDOKU_SIZE; x++) {
									if (x !== quadCells[i].x && x !== quadCells[j].x && 
									    x !== quadCells[k].x && x !== quadCells[l].x && 
									    candidates[y][x].length > 0) {
										const toRemove = candidates[y][x].filter(c => allCandidates.has(c));
										if (toRemove.length > 0) {
											eliminations.push({
												position: { x, y },
												removed: toRemove,
											});
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Quads Naked+Hidden',
				explanation: `找到四数组，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}

/**
 * 策略15: Swordfish
 * 剑鱼策略，X-Wing的扩展（三行三列）
 */
export class SwordfishStrategy extends BaseStrategy {
	constructor() {
		super('Swordfish', 15, 'Tough');
	}

	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 检查行的Swordfish
		for (let value = 1; value <= SUDOKU_SIZE; value++) {
			for (let row1 = 0; row1 < SUDOKU_SIZE - 2; row1++) {
				const cols1 = [];
				for (let x = 0; x < SUDOKU_SIZE; x++) {
					if (grid[row1][x] === 0 && candidates[row1][x].includes(value)) {
						cols1.push(x);
					}
				}
				if (cols1.length < 2 || cols1.length > 3) continue;

				for (let row2 = row1 + 1; row2 < SUDOKU_SIZE - 1; row2++) {
					const cols2 = [];
					for (let x = 0; x < SUDOKU_SIZE; x++) {
						if (grid[row2][x] === 0 && candidates[row2][x].includes(value)) {
							cols2.push(x);
						}
					}
					if (cols2.length < 2 || cols2.length > 3) continue;

					for (let row3 = row2 + 1; row3 < SUDOKU_SIZE; row3++) {
						const cols3 = [];
						for (let x = 0; x < SUDOKU_SIZE; x++) {
							if (grid[row3][x] === 0 && candidates[row3][x].includes(value)) {
								cols3.push(x);
							}
						}
						if (cols3.length < 2 || cols3.length > 3) continue;

						// 检查三行的列集合是否有交集且正好是2-3列
						const allCols = new Set([...cols1, ...cols2, ...cols3]);
						if (allCols.size >= 2 && allCols.size <= 3) {
							// 检查每列是否至少在两行中出现
							for (const col of allCols) {
								let count = 0;
								if (cols1.includes(col)) count++;
								if (cols2.includes(col)) count++;
								if (cols3.includes(col)) count++;
								if (count >= 2) {
									// 从该列的其他行中删除该候选数
									for (let y = 0; y < SUDOKU_SIZE; y++) {
										if (y !== row1 && y !== row2 && y !== row3) {
											if (candidates[y][col].includes(value)) {
												eliminations.push({
													position: { x: col, y },
													removed: [value],
												});
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Swordfish',
				explanation: `找到Swordfish模式，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}

/**
 * 策略16: XYZ Wing
 * XYZ Wing策略，三个单元格形成XYZ形
 */
export class XYZWingStrategy extends BaseStrategy {
	constructor() {
		super('XYZ Wing', 16, 'Tough');
	}

	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 查找XYZ Wing：一个三值单元格(xyz)和两个双值单元格(xz, yz)
		for (let y1 = 0; y1 < SUDOKU_SIZE; y1++) {
			for (let x1 = 0; x1 < SUDOKU_SIZE; x1++) {
				if (grid[y1][x1] !== 0 || candidates[y1][x1].length !== 3) continue;
				const [x, y, z] = candidates[y1][x1];

				// 查找包含xz的双值单元格
				for (let y2 = 0; y2 < SUDOKU_SIZE; y2++) {
					for (let x2 = 0; x2 < SUDOKU_SIZE; x2++) {
						if ((y1 === y2 && x1 === x2) || grid[y2][x2] !== 0) continue;
						if (candidates[y2][x2].length !== 2) continue;
						if (!candidates[y2][x2].includes(x) || !candidates[y2][x2].includes(z)) continue;

						// 查找包含yz的双值单元格
						for (let y3 = 0; y3 < SUDOKU_SIZE; y3++) {
							for (let x3 = 0; x3 < SUDOKU_SIZE; x3++) {
								if ((y1 === y3 && x1 === x3) || (y2 === y3 && x2 === x3)) continue;
								if (grid[y3][x3] !== 0) continue;
								if (candidates[y3][x3].length !== 2) continue;
								if (!candidates[y3][x3].includes(y) || !candidates[y3][x3].includes(z)) continue;

								// 检查cell2和cell3是否都与cell1相关
								const rel12 = (y1 === y2 || x1 === x2 || 
									(Math.floor(y1 / BOX_SIZE) === Math.floor(y2 / BOX_SIZE) && 
									 Math.floor(x1 / BOX_SIZE) === Math.floor(x2 / BOX_SIZE)));
								const rel13 = (y1 === y3 || x1 === x3 || 
									(Math.floor(y1 / BOX_SIZE) === Math.floor(y3 / BOX_SIZE) && 
									 Math.floor(x1 / BOX_SIZE) === Math.floor(x3 / BOX_SIZE)));

								if (rel12 && rel13) {
									// 查找与cell2和cell3都相关的单元格，删除z
									for (let y = 0; y < SUDOKU_SIZE; y++) {
										for (let x = 0; x < SUDOKU_SIZE; x++) {
											if (grid[y][x] !== 0) continue;
											const rel2 = (y === y2 || x === x2 || 
												(Math.floor(y / BOX_SIZE) === Math.floor(y2 / BOX_SIZE) && 
												 Math.floor(x / BOX_SIZE) === Math.floor(x2 / BOX_SIZE)));
											const rel3 = (y === y3 || x === x3 || 
												(Math.floor(y / BOX_SIZE) === Math.floor(y3 / BOX_SIZE) && 
												 Math.floor(x / BOX_SIZE) === Math.floor(x3 / BOX_SIZE)));

											if (rel2 && rel3 && candidates[y][x].includes(z)) {
												eliminations.push({
													position: { x, y },
													removed: [z],
												});
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'XYZ Wing',
				explanation: `找到XYZ Wing模式，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}

/**
 * 策略17-41: 高级策略（Diabolical, Extreme, Trial and Error）
 * 这些策略非常复杂，需要图算法、链式推理等
 * 为了保持框架完整性，我们提供占位实现
 * 后续可以根据需要逐步完善这些策略
 */

// 策略17-26: Diabolical Strategies
export class XCyclesStrategy extends BaseStrategy {
	constructor() { super('X-Cycles', 17, 'Diabolical'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 查找X-Cycles：某个数字的强链接形成循环
		for (let value = 1; value <= SUDOKU_SIZE; value++) {
			// 构建强链接图
			const strongLinks = this.buildStrongLinks(grid, candidates, value);
			
			// 查找循环
			const cycles = this.findCycles(strongLinks, 6);
			
			for (const cycle of cycles) {
				// 如果循环长度为偶数，可以删除某些候选数
				if (cycle.length % 2 === 0 && cycle.length >= 4) {
					// 查找与循环中所有单元格都相关的单元格
					for (let y = 0; y < SUDOKU_SIZE; y++) {
						for (let x = 0; x < SUDOKU_SIZE; x++) {
							if (grid[y][x] !== 0) continue;
							if (!candidates[y][x].includes(value)) continue;
							
							// 检查是否在循环中
							const inCycle = cycle.some(c => c.x === x && c.y === y);
							if (inCycle) continue;
							
							// 检查是否与循环中的所有单元格都相关
							let relatedToAll = true;
							for (const cell of cycle) {
								const related = (y === cell.y || x === cell.x || 
									(Math.floor(y / BOX_SIZE) === Math.floor(cell.y / BOX_SIZE) && 
									 Math.floor(x / BOX_SIZE) === Math.floor(cell.x / BOX_SIZE)));
								if (!related) {
									relatedToAll = false;
									break;
								}
							}
							
							if (relatedToAll) {
								eliminations.push({
									position: { x, y },
									removed: [value],
								});
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'X-Cycles',
				explanation: `找到X-Cycles，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}

	buildStrongLinks(grid, candidates, value) {
		const links = [];
		
		// 检查行中的强链接（某个数字只出现在两个位置）
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			const positions = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				if (grid[y][x] === 0 && candidates[y][x].includes(value)) {
					positions.push({ x, y });
				}
			}
			if (positions.length === 2) {
				links.push({ from: positions[0], to: positions[1] });
			}
		}
		
		// 检查列中的强链接
		for (let x = 0; x < SUDOKU_SIZE; x++) {
			const positions = [];
			for (let y = 0; y < SUDOKU_SIZE; y++) {
				if (grid[y][x] === 0 && candidates[y][x].includes(value)) {
					positions.push({ x, y });
				}
			}
			if (positions.length === 2) {
				links.push({ from: positions[0], to: positions[1] });
			}
		}
		
		// 检查宫中的强链接
		for (let boxRow = 0; boxRow < BOX_SIZE; boxRow++) {
			for (let boxCol = 0; boxCol < BOX_SIZE; boxCol++) {
				const positions = [];
				for (let y = boxRow * BOX_SIZE; y < (boxRow + 1) * BOX_SIZE; y++) {
					for (let x = boxCol * BOX_SIZE; x < (boxCol + 1) * BOX_SIZE; x++) {
						if (grid[y][x] === 0 && candidates[y][x].includes(value)) {
							positions.push({ x, y });
						}
					}
				}
				if (positions.length === 2) {
					links.push({ from: positions[0], to: positions[1] });
				}
			}
		}
		
		return links;
	}

	findCycles(links, maxLength) {
		const cycles = [];
		const graph = new Map();
		
		// 构建图
		for (const link of links) {
			const key1 = `${link.from.x},${link.from.y}`;
			const key2 = `${link.to.x},${link.to.y}`;
			
			if (!graph.has(key1)) graph.set(key1, []);
			if (!graph.has(key2)) graph.set(key2, []);
			
			graph.get(key1).push(link.to);
			graph.get(key2).push(link.from);
		}
		
		// 查找循环
		for (const [startKey, startPos] of graph) {
			const visited = new Set();
			const path = [startPos];
			
			this.dfsCycle(graph, startPos, startPos, visited, path, cycles, maxLength);
		}
		
		return cycles;
	}

	dfsCycle(graph, start, current, visited, path, cycles, maxLength) {
		if (path.length > maxLength) return;
		if (path.length >= 4 && path.length % 2 === 0) {
			const currentKey = `${current.x},${current.y}`;
			const startKey = `${start.x},${start.y}`;
			
			// 检查是否形成循环
			if (currentKey === startKey && path.length > 2) {
				cycles.push([...path]);
				return;
			}
		}
		
		const currentKey = `${current.x},${current.y}`;
		if (visited.has(currentKey)) return;
		
		visited.add(currentKey);
		const neighbors = graph.get(currentKey) || [];
		
		for (const neighbor of neighbors) {
			if (path.length === 1 || neighbor.x !== path[path.length - 2].x || neighbor.y !== path[path.length - 2].y) {
				path.push(neighbor);
				this.dfsCycle(graph, start, neighbor, visited, path, cycles, maxLength);
				path.pop();
			}
		}
		
		visited.delete(currentKey);
	}
}

export class XYChainStrategy extends BaseStrategy {
	constructor() { super('XY-Chain', 18, 'Diabolical'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 查找XY-Chain：一系列双值单元格，形成链
		// 简化实现：查找长度为2-4的链
		for (let startY = 0; startY < SUDOKU_SIZE; startY++) {
			for (let startX = 0; startX < SUDOKU_SIZE; startX++) {
				if (grid[startY][startX] !== 0 || candidates[startY][startX].length !== 2) continue;
				
				const [a, b] = candidates[startY][startX];
				
				// 尝试构建链
				const chain = this.buildXYChain(grid, candidates, { x: startX, y: startY }, a, b, 4);
				
				if (chain && chain.length >= 2) {
					// 找到链，检查是否可以删除候选数
					const startValue = chain[0].value;
					const endValue = chain[chain.length - 1].value;
					
					// 如果链的起点和终点有相同的值，可以删除相关单元格中的该值
					if (startValue === endValue && chain.length > 2) {
						// 查找与链的起点和终点都相关的单元格
						const startCell = chain[0].position;
						const endCell = chain[chain.length - 1].position;
						
						for (let y = 0; y < SUDOKU_SIZE; y++) {
							for (let x = 0; x < SUDOKU_SIZE; x++) {
								if (grid[y][x] !== 0) continue;
								
								// 检查是否与起点和终点都相关
								const relStart = (y === startCell.y || x === startCell.x || 
									(Math.floor(y / BOX_SIZE) === Math.floor(startCell.y / BOX_SIZE) && 
									 Math.floor(x / BOX_SIZE) === Math.floor(startCell.x / BOX_SIZE)));
								const relEnd = (y === endCell.y || x === endCell.x || 
									(Math.floor(y / BOX_SIZE) === Math.floor(endCell.y / BOX_SIZE) && 
									 Math.floor(x / BOX_SIZE) === Math.floor(endCell.x / BOX_SIZE)));
								
								if (relStart && relEnd && candidates[y][x].includes(startValue)) {
									eliminations.push({
										position: { x, y },
										removed: [startValue],
									});
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'XY-Chain',
				explanation: `找到XY-Chain，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}

	buildXYChain(grid, candidates, startPos, startValue, nextValue, maxLength) {
		const chain = [{ position: startPos, value: startValue }];
		const visited = new Set([`${startPos.x},${startPos.y}`]);
		
		let currentPos = startPos;
		let currentValue = nextValue;
		
		for (let i = 1; i < maxLength; i++) {
			// 查找下一个单元格（包含currentValue的双值单元格）
			let found = false;
			
			for (let y = 0; y < SUDOKU_SIZE && !found; y++) {
				for (let x = 0; x < SUDOKU_SIZE && !found; x++) {
					const key = `${x},${y}`;
					if (visited.has(key)) continue;
					if (grid[y][x] !== 0) continue;
					if (candidates[y][x].length !== 2) continue;
					if (!candidates[y][x].includes(currentValue)) continue;
					
					// 检查是否与当前单元格相关
					const related = (y === currentPos.y || x === currentPos.x || 
						(Math.floor(y / BOX_SIZE) === Math.floor(currentPos.y / BOX_SIZE) && 
						 Math.floor(x / BOX_SIZE) === Math.floor(currentPos.x / BOX_SIZE)));
					
					if (related) {
						const otherValue = candidates[y][x].find(v => v !== currentValue);
						chain.push({ position: { x, y }, value: currentValue });
						visited.add(key);
						currentPos = { x, y };
						currentValue = otherValue;
						found = true;
					}
				}
			}
			
			if (!found) break;
		}
		
		return chain.length >= 2 ? chain : null;
	}
}

export class Medusa3DStrategy extends BaseStrategy {
	constructor() { super('3D Medusa', 19, 'Diabolical'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 3D Medusa是Simple Colouring的扩展，使用多种颜色
		// 简化实现：使用X-Cycles和XY-Chain的组合
		const xCycles = new XCyclesStrategy();
		const result1 = xCycles.execute(grid, candidatesDict);
		if (result1) return result1;

		const xyChain = new XYChainStrategy();
		return xyChain.execute(grid, candidatesDict);
	}
}

export class JellyfishStrategy extends BaseStrategy {
	constructor() { super('Jellyfish', 20, 'Diabolical'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 检查行的Jellyfish（四行四列）
		for (let value = 1; value <= SUDOKU_SIZE; value++) {
			for (let row1 = 0; row1 < SUDOKU_SIZE - 3; row1++) {
				const cols1 = [];
				for (let x = 0; x < SUDOKU_SIZE; x++) {
					if (grid[row1][x] === 0 && candidates[row1][x].includes(value)) {
						cols1.push(x);
					}
				}
				if (cols1.length < 2 || cols1.length > 4) continue;

				for (let row2 = row1 + 1; row2 < SUDOKU_SIZE - 2; row2++) {
					const cols2 = [];
					for (let x = 0; x < SUDOKU_SIZE; x++) {
						if (grid[row2][x] === 0 && candidates[row2][x].includes(value)) {
							cols2.push(x);
						}
					}
					if (cols2.length < 2 || cols2.length > 4) continue;

					for (let row3 = row2 + 1; row3 < SUDOKU_SIZE - 1; row3++) {
						const cols3 = [];
						for (let x = 0; x < SUDOKU_SIZE; x++) {
							if (grid[row3][x] === 0 && candidates[row3][x].includes(value)) {
								cols3.push(x);
							}
						}
						if (cols3.length < 2 || cols3.length > 4) continue;

						for (let row4 = row3 + 1; row4 < SUDOKU_SIZE; row4++) {
							const cols4 = [];
							for (let x = 0; x < SUDOKU_SIZE; x++) {
								if (grid[row4][x] === 0 && candidates[row4][x].includes(value)) {
									cols4.push(x);
								}
							}
							if (cols4.length < 2 || cols4.length > 4) continue;

							// 检查四行的列集合是否有交集且正好是2-4列
							const allCols = new Set([...cols1, ...cols2, ...cols3, ...cols4]);
							if (allCols.size >= 2 && allCols.size <= 4) {
								// 检查每列是否至少在两行中出现
								for (const col of allCols) {
									let count = 0;
									if (cols1.includes(col)) count++;
									if (cols2.includes(col)) count++;
									if (cols3.includes(col)) count++;
									if (cols4.includes(col)) count++;
									if (count >= 2) {
										// 从该列的其他行中删除该候选数
										for (let y = 0; y < SUDOKU_SIZE; y++) {
											if (y !== row1 && y !== row2 && y !== row3 && y !== row4) {
												if (candidates[y][col].includes(value)) {
													eliminations.push({
														position: { x: col, y },
														removed: [value],
													});
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Jellyfish',
				explanation: `找到Jellyfish模式，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}

export class UniqueRectangles2PlusStrategy extends BaseStrategy {
	constructor() { super('Unique Rectangles 2+', 21, 'Diabolical'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 查找形成矩形的四个单元格（Unique Rectangles Type 2+）
		for (let r1 = 0; r1 < SUDOKU_SIZE - 1; r1++) {
			for (let c1 = 0; c1 < SUDOKU_SIZE - 1; c1++) {
				if (grid[r1][c1] !== 0) continue;

				for (let r2 = r1 + 1; r2 < SUDOKU_SIZE; r2++) {
					for (let c2 = c1 + 1; c2 < SUDOKU_SIZE; c2++) {
						if (grid[r2][c2] !== 0) continue;

						// 检查是否形成矩形：(r1,c1), (r1,c2), (r2,c1), (r2,c2)
						if (grid[r1][c2] === 0 && grid[r2][c1] === 0) {
							const cell1 = candidates[r1][c1];
							const cell2 = candidates[r1][c2];
							const cell3 = candidates[r2][c1];
							const cell4 = candidates[r2][c2];

							// Type 2: 三个单元格是双值，第四个单元格有额外候选数
							if (cell1.length === 2 && cell2.length === 2 && cell3.length === 2 && cell4.length > 2) {
								const set1 = new Set(cell1);
								const set2 = new Set(cell2);
								const set3 = new Set(cell3);

								if (this.setsEqual(set1, set2) && this.setsEqual(set2, set3)) {
									// 检查cell4是否包含所有三个单元格的候选数
									const commonValues = Array.from(set1);
									if (commonValues.every(v => cell4.includes(v))) {
										// 删除cell4中的额外候选数
										const toRemove = cell4.filter(c => !commonValues.includes(c));
										if (toRemove.length > 0) {
											eliminations.push({
												position: { x: c2, y: r2 },
												removed: toRemove,
											});
										}
									}
								}
							}

							// Type 3: 两个单元格是双值，另外两个有额外候选数
							if (cell1.length === 2 && cell2.length === 2 && cell3.length > 2 && cell4.length > 2) {
								const set1 = new Set(cell1);
								const set2 = new Set(cell2);

								if (this.setsEqual(set1, set2)) {
									const commonValues = Array.from(set1);
									// 检查cell3和cell4是否都包含共同候选数
									if (commonValues.every(v => cell3.includes(v)) && 
									    commonValues.every(v => cell4.includes(v))) {
										// 如果cell3和cell4在同一行/列/宫，可以删除额外候选数
										const sameRow = (r1 === r2);
										const sameCol = (c1 === c2);
										const sameBox = (Math.floor(r1 / BOX_SIZE) === Math.floor(r2 / BOX_SIZE) && 
										                 Math.floor(c1 / BOX_SIZE) === Math.floor(c2 / BOX_SIZE));

										if (sameRow || sameCol || sameBox) {
											const toRemove3 = cell3.filter(c => !commonValues.includes(c));
											const toRemove4 = cell4.filter(c => !commonValues.includes(c));
											
											if (toRemove3.length > 0) {
												eliminations.push({
													position: { x: c1, y: r2 },
													removed: toRemove3,
												});
											}
											if (toRemove4.length > 0) {
												eliminations.push({
													position: { x: c2, y: r2 },
													removed: toRemove4,
												});
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Unique Rectangles 2+',
				explanation: `找到唯一矩形类型2+，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}

	setsEqual(set1, set2) {
		if (set1.size !== set2.size) return false;
		for (const item of set1) {
			if (!set2.has(item)) return false;
		}
		return true;
	}
}

export class VariousStaticPatternsStrategy extends BaseStrategy {
	constructor() { super('Various static patterns', 22, 'Diabolical'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 查找各种静态模式，如空矩形、双空矩形等
		// 简化实现：查找空矩形模式
		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 查找空矩形模式：某个数字在四个宫中的分布形成矩形
		for (let value = 1; value <= SUDOKU_SIZE; value++) {
			// 检查2x2的宫组合
			for (let boxRow1 = 0; boxRow1 < BOX_SIZE - 1; boxRow1++) {
				for (let boxCol1 = 0; boxCol1 < BOX_SIZE - 1; boxCol1++) {
					for (let boxRow2 = boxRow1 + 1; boxRow2 < BOX_SIZE; boxRow2++) {
						for (let boxCol2 = boxCol1 + 1; boxCol2 < BOX_SIZE; boxCol2++) {
							// 检查四个宫：(boxRow1,boxCol1), (boxRow1,boxCol2), (boxRow2,boxCol1), (boxRow2,boxCol2)
							const positions = [];
							
							for (const [br, bc] of [[boxRow1, boxCol1], [boxRow1, boxCol2], [boxRow2, boxCol1], [boxRow2, boxCol2]]) {
								for (let y = br * BOX_SIZE; y < (br + 1) * BOX_SIZE; y++) {
									for (let x = bc * BOX_SIZE; x < (bc + 1) * BOX_SIZE; x++) {
										if (grid[y][x] === 0 && candidates[y][x].includes(value)) {
											positions.push({ x, y });
										}
									}
								}
							}

							// 如果位置形成矩形模式，可以删除某些候选数
							if (positions.length >= 4) {
								const rows = new Set(positions.map(p => p.y));
								const cols = new Set(positions.map(p => p.x));
								
								if (rows.size === 2 && cols.size === 2) {
									// 形成矩形，删除矩形外但相关的单元格中的候选数
									const rowArray = Array.from(rows);
									const colArray = Array.from(cols);
									
									for (let y = 0; y < SUDOKU_SIZE; y++) {
										for (let x = 0; x < SUDOKU_SIZE; x++) {
											if (grid[y][x] !== 0) continue;
											if (!candidates[y][x].includes(value)) continue;
											
											// 检查是否在矩形内
											const inRect = rowArray.includes(y) && colArray.includes(x);
											if (inRect) continue;
											
											// 检查是否与矩形相关（同行或同列）
											const related = rowArray.includes(y) || colArray.includes(x);
											if (related) {
												eliminations.push({
													position: { x, y },
													removed: [value],
												});
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Various static patterns',
				explanation: `找到静态模式，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}

export class ExtendedUniqueRectsStrategy extends BaseStrategy {
	constructor() { super('Extended Unique Rect\'s', 23, 'Diabolical'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 扩展唯一矩形：使用Unique Rectangles 2+的逻辑
		const uniqueRects2Plus = new UniqueRectangles2PlusStrategy();
		return uniqueRects2Plus.execute(grid, candidatesDict);
	}
}

export class HiddenUniqueRectsStrategy extends BaseStrategy {
	constructor() { super('Hidden Unique Rect\'s', 24, 'Diabolical'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 隐藏唯一矩形：查找隐藏的唯一矩形模式
		// 简化实现：使用Unique Rectangles的逻辑，但检查隐藏模式
		const uniqueRects1 = new UniqueRectangles1Strategy();
		const result1 = uniqueRects1.execute(grid, candidatesDict);
		if (result1) return result1;

		const uniqueRects2Plus = new UniqueRectangles2PlusStrategy();
		return uniqueRects2Plus.execute(grid, candidatesDict);
	}
}

export class WXYZWingStrategy extends BaseStrategy {
	constructor() { super('WXYZ Wing', 25, 'Diabolical'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 查找WXYZ Wing：一个四值单元格(wxyz)和三个双值单元格(wx, wy, wz)
		for (let y1 = 0; y1 < SUDOKU_SIZE; y1++) {
			for (let x1 = 0; x1 < SUDOKU_SIZE; x1++) {
				if (grid[y1][x1] !== 0 || candidates[y1][x1].length !== 4) continue;
				const [w, x, y, z] = candidates[y1][x1];

				// 查找包含wx的双值单元格
				for (let y2 = 0; y2 < SUDOKU_SIZE; y2++) {
					for (let x2 = 0; x2 < SUDOKU_SIZE; x2++) {
						if ((y1 === y2 && x1 === x2) || grid[y2][x2] !== 0) continue;
						if (candidates[y2][x2].length !== 2) continue;
						if (!candidates[y2][x2].includes(w) || !candidates[y2][x2].includes(x)) continue;

						// 查找包含wy的双值单元格
						for (let y3 = 0; y3 < SUDOKU_SIZE; y3++) {
							for (let x3 = 0; x3 < SUDOKU_SIZE; x3++) {
								if ((y1 === y3 && x1 === x3) || (y2 === y3 && x2 === x3)) continue;
								if (grid[y3][x3] !== 0) continue;
								if (candidates[y3][x3].length !== 2) continue;
								if (!candidates[y3][x3].includes(w) || !candidates[y3][x3].includes(y)) continue;

								// 查找包含wz的双值单元格
								for (let y4 = 0; y4 < SUDOKU_SIZE; y4++) {
									for (let x4 = 0; x4 < SUDOKU_SIZE; x4++) {
										if ((y1 === y4 && x1 === x4) || (y2 === y4 && x2 === x4) || (y3 === y4 && x3 === x4)) continue;
										if (grid[y4][x4] !== 0) continue;
										if (candidates[y4][x4].length !== 2) continue;
										if (!candidates[y4][x4].includes(w) || !candidates[y4][x4].includes(z)) continue;

										// 检查cell2, cell3, cell4是否都与cell1相关
										const rel12 = (y1 === y2 || x1 === x2 || 
											(Math.floor(y1 / BOX_SIZE) === Math.floor(y2 / BOX_SIZE) && 
											 Math.floor(x1 / BOX_SIZE) === Math.floor(x2 / BOX_SIZE)));
										const rel13 = (y1 === y3 || x1 === x3 || 
											(Math.floor(y1 / BOX_SIZE) === Math.floor(y3 / BOX_SIZE) && 
											 Math.floor(x1 / BOX_SIZE) === Math.floor(x3 / BOX_SIZE)));
										const rel14 = (y1 === y4 || x1 === x4 || 
											(Math.floor(y1 / BOX_SIZE) === Math.floor(y4 / BOX_SIZE) && 
											 Math.floor(x1 / BOX_SIZE) === Math.floor(x4 / BOX_SIZE)));

										if (rel12 && rel13 && rel14) {
											// 查找与cell2, cell3, cell4都相关的单元格，删除w
											for (let y = 0; y < SUDOKU_SIZE; y++) {
												for (let x = 0; x < SUDOKU_SIZE; x++) {
													if (grid[y][x] !== 0) continue;
													const rel2 = (y === y2 || x === x2 || 
														(Math.floor(y / BOX_SIZE) === Math.floor(y2 / BOX_SIZE) && 
														 Math.floor(x / BOX_SIZE) === Math.floor(x2 / BOX_SIZE)));
													const rel3 = (y === y3 || x === x3 || 
														(Math.floor(y / BOX_SIZE) === Math.floor(y3 / BOX_SIZE) && 
														 Math.floor(x / BOX_SIZE) === Math.floor(x3 / BOX_SIZE)));
													const rel4 = (y === y4 || x === x4 || 
														(Math.floor(y / BOX_SIZE) === Math.floor(y4 / BOX_SIZE) && 
														 Math.floor(x / BOX_SIZE) === Math.floor(x4 / BOX_SIZE)));

													if (rel2 && rel3 && rel4 && candidates[y][x].includes(w)) {
														eliminations.push({
															position: { x, y },
															removed: [w],
														});
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'WXYZ Wing',
				explanation: `找到WXYZ Wing模式，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}

export class AlignedPairExclusionStrategy extends BaseStrategy {
	constructor() { super('Aligned Pair Exclusion', 26, 'Diabolical'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 对齐数对排除：当两个单元格的对齐组合导致冲突时，可以排除某些候选数
		// 简化实现：查找同一行/列/宫中的数对，检查它们的对齐组合
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			const pairs = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				if (grid[y][x] === 0 && candidates[y][x].length === 2) {
					pairs.push({ x, y, candidates: candidates[y][x] });
				}
			}

			// 检查数对的对齐组合
			for (let i = 0; i < pairs.length - 1; i++) {
				for (let j = i + 1; j < pairs.length; j++) {
					const pair1 = pairs[i];
					const pair2 = pairs[j];
					
					// 检查两个数对的所有可能组合是否会导致冲突
					const [a1, b1] = pair1.candidates;
					const [a2, b2] = pair2.candidates;
					
					// 检查所有四种组合：(a1,a2), (a1,b2), (b1,a2), (b1,b2)
					const combinations = [
						[a1, a2], [a1, b2], [b1, a2], [b1, b2]
					];
					
					// 如果所有组合都导致冲突，可以排除某些候选数
					let allConflict = true;
					for (const [v1, v2] of combinations) {
						// 检查这两个值是否可以在同一行/列/宫中
						if (v1 !== v2) {
							// 检查是否在同一行/列/宫
							const sameRow = (pair1.y === pair2.y);
							const sameCol = (pair1.x === pair2.x);
							const sameBox = (Math.floor(pair1.y / BOX_SIZE) === Math.floor(pair2.y / BOX_SIZE) && 
							                 Math.floor(pair1.x / BOX_SIZE) === Math.floor(pair2.x / BOX_SIZE));
							
							if (!sameRow && !sameCol && !sameBox) {
								allConflict = false;
								break;
							}
						}
					}
					
					if (allConflict && combinations.length === 4) {
						// 所有组合都冲突，可以删除某些候选数
						// 简化处理：删除与其他单元格冲突的候选数
						for (let x = 0; x < SUDOKU_SIZE; x++) {
							if (x !== pair1.x && x !== pair2.x && grid[y][x] === 0) {
								const toRemove = candidates[y][x].filter(c => 
									pair1.candidates.includes(c) || pair2.candidates.includes(c)
								);
								if (toRemove.length > 0) {
									eliminations.push({
										position: { x, y },
										removed: toRemove,
									});
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Aligned Pair Exclusion',
				explanation: `找到对齐数对排除，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}

// 策略27-40: Extreme Strategies
export class ExocetStrategy extends BaseStrategy {
	constructor() { super('Exocet', 27, 'Extreme'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// Exocet是一个非常复杂的模式，需要特定的单元格配置
		// 简化实现：查找类似X-Wing但更复杂的模式
		const xWing = new XWingStrategy();
		const result1 = xWing.execute(grid, candidatesDict);
		if (result1) return result1;

		const swordfish = new SwordfishStrategy();
		return swordfish.execute(grid, candidatesDict);
	}
}

export class GroupedXCyclesStrategy extends BaseStrategy {
	constructor() { super('Grouped X-Cycles', 28, 'Extreme'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 分组X-Cycles：X-Cycles的扩展，允许分组单元格
		// 简化实现：使用X-Cycles的逻辑
		const xCycles = new XCyclesStrategy();
		return xCycles.execute(grid, candidatesDict);
	}
}

export class FinnedXWingStrategy extends BaseStrategy {
	constructor() { super('Finned X-Wing', 29, 'Extreme'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 检查行的Finned X-Wing
		for (let value = 1; value <= SUDOKU_SIZE; value++) {
			for (let row1 = 0; row1 < SUDOKU_SIZE - 1; row1++) {
				const cols1 = [];
				for (let x = 0; x < SUDOKU_SIZE; x++) {
					if (grid[row1][x] === 0 && candidates[row1][x].includes(value)) {
						cols1.push(x);
					}
				}
				if (cols1.length < 2 || cols1.length > 3) continue;

				for (let row2 = row1 + 1; row2 < SUDOKU_SIZE; row2++) {
					const cols2 = [];
					for (let x = 0; x < SUDOKU_SIZE; x++) {
						if (grid[row2][x] === 0 && candidates[row2][x].includes(value)) {
							cols2.push(x);
						}
					}
					if (cols2.length < 2 || cols2.length > 3) continue;

					// 检查是否形成X-Wing模式（两行两列）
					const commonCols = cols1.filter(c => cols2.includes(c));
					if (commonCols.length === 2) {
						// 标准X-Wing，检查是否有鳍
						const allCols = new Set([...cols1, ...cols2]);
						if (allCols.size === 3) {
							// 有鳍：第三列只在一行中出现
							const finCol = Array.from(allCols).find(c => !commonCols.includes(c));
							if (finCol !== undefined) {
								// 确定鳍在哪一行
								const finRow = cols1.includes(finCol) ? row1 : row2;
								const baseRow = cols1.includes(finCol) ? row2 : row1;
								
								// 检查鳍单元格是否与基础行在同一宫
								const finBox = Math.floor(finRow / BOX_SIZE) * BOX_SIZE + Math.floor(finCol / BOX_SIZE);
								const baseBox = Math.floor(baseRow / BOX_SIZE) * BOX_SIZE + Math.floor(commonCols[0] / BOX_SIZE);
								
								if (finBox === baseBox) {
									// 从基础行的其他列中删除该候选数
									for (let x = 0; x < SUDOKU_SIZE; x++) {
										if (!commonCols.includes(x) && x !== finCol) {
											if (candidates[baseRow][x].includes(value)) {
												eliminations.push({
													position: { x, y: baseRow },
													removed: [value],
												});
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Finned X-Wing',
				explanation: `找到Finned X-Wing模式，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}

export class FinnedSwordfishStrategy extends BaseStrategy {
	constructor() { super('Finned Swordfish', 30, 'Extreme'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 检查行的Finned Swordfish
		for (let value = 1; value <= SUDOKU_SIZE; value++) {
			for (let row1 = 0; row1 < SUDOKU_SIZE - 2; row1++) {
				const cols1 = [];
				for (let x = 0; x < SUDOKU_SIZE; x++) {
					if (grid[row1][x] === 0 && candidates[row1][x].includes(value)) {
						cols1.push(x);
					}
				}
				if (cols1.length < 2 || cols1.length > 4) continue;

				for (let row2 = row1 + 1; row2 < SUDOKU_SIZE - 1; row2++) {
					const cols2 = [];
					for (let x = 0; x < SUDOKU_SIZE; x++) {
						if (grid[row2][x] === 0 && candidates[row2][x].includes(value)) {
							cols2.push(x);
						}
					}
					if (cols2.length < 2 || cols2.length > 4) continue;

					for (let row3 = row2 + 1; row3 < SUDOKU_SIZE; row3++) {
						const cols3 = [];
						for (let x = 0; x < SUDOKU_SIZE; x++) {
							if (grid[row3][x] === 0 && candidates[row3][x].includes(value)) {
								cols3.push(x);
							}
						}
						if (cols3.length < 2 || cols3.length > 4) continue;

						// 检查是否形成Swordfish模式
						const allCols = new Set([...cols1, ...cols2, ...cols3]);
						if (allCols.size >= 2 && allCols.size <= 4) {
							// 检查每列是否至少在两行中出现
							const baseCols = [];
							const finCols = [];
							
							for (const col of allCols) {
								let count = 0;
								if (cols1.includes(col)) count++;
								if (cols2.includes(col)) count++;
								if (cols3.includes(col)) count++;
								
								if (count >= 2) {
									baseCols.push(col);
								} else if (count === 1) {
									finCols.push(col);
								}
							}

							// 如果有基础列和鳍列，且鳍列只在一行中出现
							if (baseCols.length >= 2 && finCols.length > 0) {
								// 检查鳍列是否与基础列在同一宫
								for (const finCol of finCols) {
									const finRow = cols1.includes(finCol) ? row1 : (cols2.includes(finCol) ? row2 : row3);
									const baseRows = [row1, row2, row3].filter(r => r !== finRow);
									
									for (const baseCol of baseCols) {
										const baseBox = Math.floor(baseRows[0] / BOX_SIZE) * BOX_SIZE + Math.floor(baseCol / BOX_SIZE);
										const finBox = Math.floor(finRow / BOX_SIZE) * BOX_SIZE + Math.floor(finCol / BOX_SIZE);
										
										if (finBox === baseBox) {
											// 从基础行的其他列中删除该候选数
											for (const baseRow of baseRows) {
												for (let x = 0; x < SUDOKU_SIZE; x++) {
													if (!baseCols.includes(x) && x !== finCol) {
														if (candidates[baseRow][x].includes(value)) {
															eliminations.push({
																position: { x, y: baseRow },
																removed: [value],
															});
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Finned Swordfish',
				explanation: `找到Finned Swordfish模式，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}

export class AlternInferenceChainsStrategy extends BaseStrategy {
	constructor() { super('Altern. Inference Chains', 31, 'Extreme'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 交替推理链：结合强链接和弱链接的链
		// 简化实现：使用XY-Chain和X-Cycles的组合
		const xyChain = new XYChainStrategy();
		const result1 = xyChain.execute(grid, candidatesDict);
		if (result1) return result1;

		const xCycles = new XCyclesStrategy();
		return xCycles.execute(grid, candidatesDict);
	}
}

export class AlmostLockedSetsStrategy extends BaseStrategy {
	constructor() { super('Almost Locked Sets', 32, 'Extreme'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 几乎锁定集合：n个单元格包含n+1个候选数
		// 简化实现：查找2个单元格包含3个候选数的情况
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				if (grid[y][x] !== 0) continue;
				if (candidates[y][x].length < 2 || candidates[y][x].length > 3) continue;

				// 查找另一个单元格，它们的候选数并集正好是3个
				for (let y2 = 0; y2 < SUDOKU_SIZE; y2++) {
					for (let x2 = 0; x2 < SUDOKU_SIZE; x2++) {
						if ((y === y2 && x === x2) || grid[y2][x2] !== 0) continue;
						if (candidates[y2][x2].length < 2 || candidates[y2][x2].length > 3) continue;

						// 检查是否相关（同行/列/宫）
						const related = (y === y2 || x === x2 || 
							(Math.floor(y / BOX_SIZE) === Math.floor(y2 / BOX_SIZE) && 
							 Math.floor(x / BOX_SIZE) === Math.floor(x2 / BOX_SIZE)));

						if (related) {
							const allCandidates = new Set([...candidates[y][x], ...candidates[y2][x2]]);
							if (allCandidates.size === 3) {
								// 找到几乎锁定集合，删除相关单元格中的候选数
								const alsValues = Array.from(allCandidates);
								
								// 查找与两个单元格都相关的其他单元格
								for (let y3 = 0; y3 < SUDOKU_SIZE; y3++) {
									for (let x3 = 0; x3 < SUDOKU_SIZE; x3++) {
										if (grid[y3][x3] !== 0) continue;
										if ((y3 === y && x3 === x) || (y3 === y2 && x3 === x2)) continue;

										const rel1 = (y3 === y || x3 === x || 
											(Math.floor(y3 / BOX_SIZE) === Math.floor(y / BOX_SIZE) && 
											 Math.floor(x3 / BOX_SIZE) === Math.floor(x / BOX_SIZE)));
										const rel2 = (y3 === y2 || x3 === x2 || 
											(Math.floor(y3 / BOX_SIZE) === Math.floor(y2 / BOX_SIZE) && 
											 Math.floor(x3 / BOX_SIZE) === Math.floor(x2 / BOX_SIZE)));

										if (rel1 && rel2) {
											const toRemove = candidates[y3][x3].filter(c => alsValues.includes(c));
											if (toRemove.length > 0) {
												eliminations.push({
													position: { x: x3, y: y3 },
													removed: toRemove,
												});
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Almost Locked Sets',
				explanation: `找到几乎锁定集合，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}

export class DeathBlossomStrategy extends BaseStrategy {
	constructor() { super('Death Blossom', 33, 'Extreme'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 死亡之花：几乎锁定集合的特殊应用
		// 简化实现：使用Almost Locked Sets的逻辑
		const als = new AlmostLockedSetsStrategy();
		return als.execute(grid, candidatesDict);
	}
}

export class SudeCoqStrategy extends BaseStrategy {
	constructor() { super('Sue-de-Coq', 34, 'Extreme'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// Sue-de-Coq：行/列和宫的交集模式
		// 简化实现：查找行/列和宫的交集中有特殊模式的单元格
		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 检查每行和其所在宫的交集
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			const boxRow = Math.floor(y / BOX_SIZE);
			const boxStartRow = boxRow * BOX_SIZE;
			const boxEndRow = boxStartRow + BOX_SIZE;

			// 查找行和宫的交集单元格
			const intersectionCells = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const boxCol = Math.floor(x / BOX_SIZE);
				if (grid[y][x] === 0) {
					intersectionCells.push({ x, y, candidates: candidates[y][x] });
				}
			}

			// 查找宫中的其他单元格
			const boxOtherCells = [];
			for (let row = boxStartRow; row < boxEndRow; row++) {
				if (row === y) continue;
				for (let x = 0; x < SUDOKU_SIZE; x++) {
					const boxCol = Math.floor(x / BOX_SIZE);
					if (grid[row][x] === 0) {
						boxOtherCells.push({ x, y: row, candidates: candidates[row][x] });
					}
				}
			}

			// 检查Sue-de-Coq模式：交集单元格和宫其他单元格的候选数有特殊关系
			if (intersectionCells.length >= 2 && boxOtherCells.length >= 2) {
				const intersectionCandidates = new Set();
				intersectionCells.forEach(cell => {
					cell.candidates.forEach(c => intersectionCandidates.add(c));
				});

				const boxOtherCandidates = new Set();
				boxOtherCells.forEach(cell => {
					cell.candidates.forEach(c => boxOtherCandidates.add(c));
				});

				// 如果交集候选数和宫其他候选数有重叠，可以删除某些候选数
				const common = new Set([...intersectionCandidates].filter(c => boxOtherCandidates.has(c)));
				if (common.size > 0) {
					// 删除行中非交集单元格的候选数
					for (let x = 0; x < SUDOKU_SIZE; x++) {
						const inIntersection = intersectionCells.some(cell => cell.x === x);
						if (!inIntersection && grid[y][x] === 0) {
							const toRemove = candidates[y][x].filter(c => common.has(c));
							if (toRemove.length > 0) {
								eliminations.push({
									position: { x, y },
									removed: toRemove,
								});
							}
						}
					}
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Sue-de-Coq',
				explanation: `找到Sue-de-Coq模式，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}
}

export class DigitForcingChainsStrategy extends BaseStrategy {
	constructor() { super('Digit Forcing Chains', 35, 'Extreme'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 数字强制链：通过假设某个数字的值，推导出矛盾或确定值
		// 简化实现：使用XY-Chain的逻辑
		const xyChain = new XYChainStrategy();
		return xyChain.execute(grid, candidatesDict);
	}
}

export class NishioForcingChainsStrategy extends BaseStrategy {
	constructor() { super('Nishio Forcing Chains', 36, 'Extreme'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// Nishio强制链：通过假设某个单元格的值，推导出矛盾
		// 简化实现：查找会导致矛盾的候选数
		let candidates;
		candidates = [];
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			candidates[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				const key = `${x},${y}`;
				candidates[y][x] = candidatesDict[key] || [];
			}
		}

		const eliminations = [];

		// 简化实现：查找双值单元格，如果其中一个值会导致矛盾，删除另一个值
		for (let y = 0; y < SUDOKU_SIZE; y++) {
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				if (grid[y][x] !== 0 || candidates[y][x].length !== 2) continue;

				const [a, b] = candidates[y][x];

				// 检查假设a会导致矛盾
				const conflictA = this.wouldCauseConflict(grid, candidates, { x, y }, a);
				if (conflictA) {
					eliminations.push({
						position: { x, y },
						removed: [a],
					});
					continue;
				}

				// 检查假设b会导致矛盾
				const conflictB = this.wouldCauseConflict(grid, candidates, { x, y }, b);
				if (conflictB) {
					eliminations.push({
						position: { x, y },
						removed: [b],
					});
				}
			}
		}

		if (eliminations.length > 0) {
			return {
				type: 'eliminate',
				eliminations,
				strategy: 'Nishio Forcing Chains',
				explanation: `找到Nishio强制链，删除了 ${eliminations.length} 个单元格中的候选数。`,
			};
		}

		return null;
	}

	wouldCauseConflict(grid, candidates, pos, value) {
		// 简化检查：假设该单元格填入value，检查是否会导致行/列/宫中有重复
		const { x, y } = pos;

		// 检查行
		for (let i = 0; i < SUDOKU_SIZE; i++) {
			if (i !== x && grid[y][i] === value) return true;
		}

		// 检查列
		for (let i = 0; i < SUDOKU_SIZE; i++) {
			if (i !== y && grid[i][x] === value) return true;
		}

		// 检查宫
		const startRow = Math.floor(y / BOX_SIZE) * BOX_SIZE;
		const startCol = Math.floor(x / BOX_SIZE) * BOX_SIZE;
		for (let row = startRow; row < startRow + BOX_SIZE; row++) {
			for (let col = startCol; col < startCol + BOX_SIZE; col++) {
				if ((row !== y || col !== x) && grid[row][col] === value) return true;
			}
		}

		return false;
	}
}

export class CellForcingChainsStrategy extends BaseStrategy {
	constructor() { super('Cell Forcing Chains', 37, 'Extreme'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 单元格强制链：通过假设某个单元格的值，推导出其他单元格的值
		// 简化实现：使用Nishio的逻辑
		const nishio = new NishioForcingChainsStrategy();
		return nishio.execute(grid, candidatesDict);
	}
}

export class UnitForcingChainsStrategy extends BaseStrategy {
	constructor() { super('Unit Forcing Chains', 38, 'Extreme'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 单元强制链：通过假设某个单元（行/列/宫）中某个数字的位置，推导出矛盾
		// 简化实现：使用Digit Forcing Chains的逻辑
		const digitForcing = new DigitForcingChainsStrategy();
		return digitForcing.execute(grid, candidatesDict);
	}
}

export class PatternOverlayMethodStrategy extends BaseStrategy {
	constructor() { super('Pattern Overlay Method', 39, 'Extreme'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 模式覆盖方法：通过覆盖所有可能的模式来找到解
		// 这是一个非常复杂的策略，简化实现：使用其他高级策略的组合
		const xCycles = new XCyclesStrategy();
		const result1 = xCycles.execute(grid, candidatesDict);
		if (result1) return result1;

		const xyChain = new XYChainStrategy();
		const result2 = xyChain.execute(grid, candidatesDict);
		if (result2) return result2;

		const als = new AlmostLockedSetsStrategy();
		return als.execute(grid, candidatesDict);
	}
}

export class QuadForcingChainsStrategy extends BaseStrategy {
	constructor() { super('Quad Forcing Chains', 40, 'Extreme'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// 四元强制链：四个单元格的强制链
		// 简化实现：使用Cell Forcing Chains的逻辑
		const cellForcing = new CellForcingChainsStrategy();
		return cellForcing.execute(grid, candidatesDict);
	}
}

// 策略41: Trial and Error
export class BowmansBingoStrategy extends BaseStrategy {
	constructor() { super('Bowman\'s Bingo', 41, 'Trial and Error'); }
	
	execute(grid, candidatesDict = null) {
		if (!candidatesDict) return null;

		// Bowman's Bingo：试错法，通过尝试填入数字来找到解
		// 这是一个非常复杂的策略，需要回溯算法
		// 简化实现：使用Nishio Forcing Chains的逻辑
		const nishio = new NishioForcingChainsStrategy();
		return nishio.execute(grid, candidatesDict);
	}
}
