import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';
import { IGridValidator } from '../interfaces/grid-validator.js';

/**
 * 标准9×9数独验证器
 * 
 * OOAD设计原则：
 * 1. 单一职责：只负责标准数独规则验证
 * 2. 开闭原则：可以扩展新的验证器而不修改此代码
 * 3. 策略模式：作为验证策略的一种实现
 */
export class StandardSudokuValidator extends IGridValidator {
	constructor(size = SUDOKU_SIZE, boxSize = BOX_SIZE) {
		super();
		this.size = size;
		this.boxSize = boxSize;
	}

	/**
	 * 验证网格是否符合标准数独规则
	 */
	validate(grid) {
		const conflicts = this.findConflicts(grid);
		return conflicts.length === 0;
	}

	/**
	 * 查找所有冲突的单元格
	 */
	findConflicts(grid) {
		const conflicts = [];
		const conflictSet = new Set();

		for (let y = 0; y < this.size; y++) {
			for (let x = 0; x < this.size; x++) {
				const value = grid[y][x];
				if (value === 0) continue;

				// 检查行冲突
				for (let i = 0; i < this.size; i++) {
					if (i !== x && grid[y][i] === value) {
						const key = `${x},${y}`;
						if (!conflictSet.has(key)) {
							conflictSet.add(key);
							conflicts.push({ x, y });
						}
						const key2 = `${i},${y}`;
						if (!conflictSet.has(key2)) {
							conflictSet.add(key2);
							conflicts.push({ x: i, y });
						}
					}
				}

				// 检查列冲突
				for (let i = 0; i < this.size; i++) {
					if (i !== y && grid[i][x] === value) {
						const key = `${x},${y}`;
						if (!conflictSet.has(key)) {
							conflictSet.add(key);
							conflicts.push({ x, y });
						}
						const key2 = `${x},${i}`;
						if (!conflictSet.has(key2)) {
							conflictSet.add(key2);
							conflicts.push({ x, y: i });
						}
					}
				}

				// 检查宫冲突
				const startY = Math.floor(y / this.boxSize) * this.boxSize;
				const endY = startY + this.boxSize;
				const startX = Math.floor(x / this.boxSize) * this.boxSize;
				const endX = startX + this.boxSize;
				
				for (let row = startY; row < endY; row++) {
					for (let col = startX; col < endX; col++) {
						if ((row !== y || col !== x) && grid[row][col] === value) {
							const key = `${x},${y}`;
							if (!conflictSet.has(key)) {
								conflictSet.add(key);
								conflicts.push({ x, y });
							}
							const key2 = `${col},${row}`;
							if (!conflictSet.has(key2)) {
								conflictSet.add(key2);
								conflicts.push({ x: col, y: row });
							}
						}
					}
				}
			}
		}

		return conflicts;
	}

	/**
	 * 检查指定位置是否有冲突
	 */
	hasConflictAt(grid, x, y) {
		const value = grid[y][x];
		if (value === 0) return false;

		// 检查行
		for (let i = 0; i < this.size; i++) {
			if (i !== x && grid[y][i] === value) return true;
		}

		// 检查列
		for (let i = 0; i < this.size; i++) {
			if (i !== y && grid[i][x] === value) return true;
		}

		// 检查宫
		const startY = Math.floor(y / this.boxSize) * this.boxSize;
		const endY = startY + this.boxSize;
		const startX = Math.floor(x / this.boxSize) * this.boxSize;
		const endX = startX + this.boxSize;
		
		for (let row = startY; row < endY; row++) {
			for (let col = startX; col < endX; col++) {
				if ((row !== y || col !== x) && grid[row][col] === value) {
					return true;
				}
			}
		}

		return false;
	}
}